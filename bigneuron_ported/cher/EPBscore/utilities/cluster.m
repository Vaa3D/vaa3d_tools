function T = cluster(Z, varargin)
%CLUSTER Construct clusters from LINKAGE output.
%   T = CLUSTER(Z,'CUTOFF',C) constructs clusters from cluster
%   tree Z.  Z is a matrix of size M-1 by 3, generated by LINKAGE.
%   C is a threshold for cutting the hierarchical tree generated
%   by LINKAGE into clusters.  Clusters are formed when
%   inconsistent values are less than CUTOFF (see INCONSISTENT).
%   The output T is a vector of size M that contains the cluster
%   number for each observation in the original data.
%
%   T = CLUSTER(Z,'MAXCLUST',N) specifies N as the maximum
%   number of clusters to form from the hierarchical tree in Z.
%
%   T = CLUSTER(...,'CRITERION','CRIT') uses the specified
%   criterion for forming clusters, where 'CRIT' is either
%   'inconsistent' or 'distance'.
%
%   T = CLUSTER(...,'DEPTH',D) evaluates inconsistent values to
%   a depth of D in the tree.  The default is D=2.
%
%   See also PDIST, LINKAGE, COPHENET, INCONSISTENT, CLUSTERDATA.
   
%   Obsolete former syntax:
%   T = CLUSTER(Z, CUTOFF, DEPTH, FLAG) overrides the default
%   interpretation of CUTOFF.  If FLAG is 'clusters', CUTOFF is
%   interpreted as the maximum number of clusters to keep.  If
%   FLAG is 'inconsistent', clusters are split when inconsistent
%   values are greater than CUTOFF.  If FLAG is 'distance', CUTOFF
%   clusters are split when distance values are greater than CUTOFF. 
    
%   Copyright 1993-2002 The MathWorks, Inc. 
%   $Revision: 1.3 $   $Date: 2011-03-09 10:20:21 $

if nargin < 2
   error('Not enough input arguments.');
end
depth = 2;
criterion = 'inconsistent';
maxclust = Inf;
cutoff = NaN;

% For backward compatibility, handle older syntax
if ~ischar(varargin{1})
   cutoff = varargin{1};
   if nargin >= 3
      depth = varargin{2};;
   end
   if nargin < 4
      if (cutoff >= 2) & (cutoff == fix(cutoff))
         maxclust = cutoff;
         cutoff = NaN;
      end
   else
      flag = varargin{3};
      j = strmatch(flag, strvcat('clusters','inconsistent'));
      if isempty(j),
         error('FLAG value must be ''clusters'' or ''inconsistent''');
      end
      if j==1
         maxclust = cutoff;
         cutoff = NaN;
      end
   end

% Otherwise, must have param/value pairs
else
   if rem(nargin,2)==0
      error('Incorrect number of arguments to CLUSTER.');
   end
   okargs = strvcat('cutoff','maxclust','criterion','depth');
   for j=1:2:nargin-1
      pname = varargin{j};
      pval = varargin{j+1};
      k = strmatch(lower(pname), okargs);
      if isempty(k)
         error(sprintf('Unknown parameter name:  %s.',pname));
      elseif length(k)>1
         error(sprintf('Ambiguous parameter name:  %s.',pname));
      else
         switch(k)
          case 1
            cutoff = pval;
          case 2
            maxclust = pval;
          case 3
            okcrit = strvcat('inconsistent','distance');
            kk = strmatch(lower(pval),strvcat('inconsistent','distance'));
            if length(kk)~=1
               error('Bad clustering criterion.');
            else
               criterion = deblank(okcrit(kk,:));
            end
          case 4
            depth = pval;
         end
      end
   end
end

% Check arguments
if length(maxclust)~=1 | ~isnumeric(maxclust) | (isfinite(maxclust) & maxclust<1)
   error('The MAXCLUST value must be a number 1 or larger.');
end
if length(depth)~=1 | ~isnumeric(depth) | ~isfinite(depth) | depth<1
   error('The DEPTH value must be at least 1.');
end
if isnan(cutoff)
   if ~isfinite(maxclust)
      error('Must specify a MAXCLUST or CUTOFF value.');
   end
else
   if ~isinf(maxclust)
      error('Must specify a MAXCLUST or CUTOFF value, but not both.');
   elseif cutoff<=0
      error('CUTOFF must be positive.');
   end
end

% Start of algorithm
m = size(Z,1)+1;
T = zeros(m,1);

if isinf(maxclust) % inconsistency or distance cutoff criterion for forming clusters
   if isequal(criterion,'inconsistent')
      Y = inconsistent(Z,depth);
      crit = Y(:,4);
   else
      crit = Z(:,3);  % distance criterion
   end
   conn = checkcut(Z, cutoff, crit);
   T = labeltree(Z, conn);
else % maximum number of clusters based on inconsistency
   if m <= maxclust
      T = (1:m)';
   elseif maxclust==1
      T = ones(m,1);
   else
      clsnum = 1;
      for k = (m-maxclust+1):(m-1)
         i = Z(k,1); % left tree
         if i <= m % original node, no leafs
            T(i) = clsnum;
            clsnum = clsnum + 1;
         elseif i < (2*m-maxclust+1) % created before cutoff, search down the tree
            T = clusternum(Z, T, i-m, clsnum);
            clsnum = clsnum + 1;
         end
         i = Z(k,2); % right tree
         if i <= m  % original node, no leafs
            T(i) = clsnum;
            clsnum = clsnum + 1;
         elseif i < (2*m-maxclust+1) % created before cutoff, search down the tree
            T = clusternum(Z, T, i-m, clsnum);
            clsnum = clsnum + 1;
         end
      end
   end
end

% -------- assign leaves under cluster c to c.
function T = clusternum(X, T, k, c)

m = size(X,1)+1;
while(~isempty(k))
   % Get the children of nodes at this level
   children = X(k,1:2);
   children = children(:);

   % Assign this node number to leaf children
   t = (children<=m);
   T(children(t)) = c;
   
   % Move to next level
   k = children(~t) - m;
end


% -------- assign cluster numbers
function T = labeltree(X,conn)
   
n = size(X,1);
nleaves = n+1;
T = ones(n+1,1);

% Each cut potentially yields an additional cluster
todo = true(n,1);

% Define cluster numbers for each side of each non-leaf node
clustlist = reshape(1:2*n,n,2);

% Propagate cluster numbers down the tree
while(any(todo))
   % Work on rows that are now split but not yet processed
   rows = find(todo & ~conn);
   if isempty(rows), break; end
   
   for j=1:2    % 1=left, 2=right
      children = X(rows,j);
   
      % Assign cluster number to child leaf node
      leaf = (children <= nleaves);
      if any(leaf)
         T(children(leaf)) = clustlist(rows(leaf),j);
      end
   
      % Also assign it to both children of any joined child non-leaf nodes
      joint = ~leaf;
      joint(joint) = conn(children(joint)-nleaves);
      if any(joint)
         clustnum = clustlist(rows(joint),j);
         childnum = children(joint) - nleaves;
         clustlist(childnum,1) = clustnum;
         clustlist(childnum,2) = clustnum;
         conn(childnum) = 0;
      end
   end

   % Mark these rows as done  
   todo(rows) = 0;
end

% Renumber starting from 1
[xx1,xx2,T] = unique(T);


% -------- cut the tree at a specified point
function conn = checkcut(X, cutoff, crit)

% See which nodes are below the cutoff, disconnect those that aren't
n = size(X,1)+1;
conn = (crit <= cutoff);  % these are still connected

% We may still disconnect a node unless all non-leaf children are
% below the cutoff, and grand-children, and so on
todo = conn & (X(:,1)>n | X(:,2)>n);
while(any(todo))
   rows = find(todo);
   
   % See if each child is done, or if it requires disconnecting its parent
   cdone = true(length(rows),2);
   for j=1:2     % 1=left child, 2=right child
      crows = X(rows,j);
      t = (crows>n);
      if any(t)
         child = crows(t)-n;
         cdone(t,j) = ~todo(child);
         conn(rows(t)) = conn(rows(t)) & conn(child);
      end
   end

   % Update todo list
   todo(rows(cdone(:,1) & cdone(:,2))) = 0;
end

