/*
 * Copyright (c)2006-2010  Hanchuan Peng (Janelia Farm, Howard Hughes Medical Institute).  
 * All rights reserved.
 */


/************
                                            ********* LICENSE NOTICE ************

This folder contains all source codes for the V3D project, which is subject to the following conditions if you want to use it. 

You will ***have to agree*** the following terms, *before* downloading/using/running/editing/changing any portion of codes in this package.

1. This package is free for non-profit research, but needs a special license for any commercial purpose. Please contact Hanchuan Peng for details.

2. You agree to appropriately cite this work in your related studies and publications.

Peng, H., Ruan, Z., Long, F., Simpson, J.H., and Myers, E.W. (2010) “V3D enables real-time 3D visualization and quantitative analysis of large-scale biological image data sets,” Nature Biotechnology, Vol. 28, No. 4, pp. 348-353, DOI: 10.1038/nbt.1612. ( http://penglab.janelia.org/papersall/docpdf/2010_NBT_V3D.pdf )

Peng, H, Ruan, Z., Atasoy, D., and Sternson, S. (2010) “Automatic reconstruction of 3D neuron structures using a graph-augmented deformable model,” Bioinformatics, Vol. 26, pp. i38-i46, 2010. ( http://penglab.janelia.org/papersall/docpdf/2010_Bioinfo_GD_ISMB2010.pdf )

3. This software is provided by the copyright holders (Hanchuan Peng), Howard Hughes Medical Institute, Janelia Farm Research Campus, and contributors "as is" and any express or implied warranties, including, but not limited to, any implied warranties of merchantability, non-infringement, or fitness for a particular purpose are disclaimed. In no event shall the copyright owner, Howard Hughes Medical Institute, Janelia Farm Research Campus, or contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; reasonable royalties; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage.

4. Neither the name of the Howard Hughes Medical Institute, Janelia Farm Research Campus, nor Hanchuan Peng, may be used to endorse or promote products derived from this software without specific prior written permission.

*************/




/*
 *  stackutil.cpp
 *
 *
 *  Created (extracted from earlier codes) by Hanchuan Peng on 7/31/06.
 *  Modified on 060803 by Hanchuan Peng: change the size information to be 4 V3DLONG (4-byte) instead of 4-short-int (2byte).
 *  Updated 060806: correct a bug in 4-byte swapping. And notice the compatibility of 32-bit system and 64-bit system about the length of int/V3DLONG types
 *  Copyright 2006 __Hanchuan Peng__. All rights reserved.
 *
 *  060816: add tif support
 *  060828: add surfix extraction function here
 *
 *  060920: add 2-byte formatted raw format support back to increase the compatibility of existing data in the worm project
 *
 *  070214: add two simple interface to read any file formats supported (raw or tif) based on the surfix of filename
 *  070220: add b_VERBOSE_PRINT
 *  070306: add tif file exist verification
 * 070713: George tried to add lsm file reading functions but unsucecssful
 * 070806: Hanchuan added lsm 8-bit reading functions
 * 070807/08: try to handle the imcomplete data generated by the Zeiss lsm writer. The current solution is to change the a function in libtiff tif_lzw.c file
 *            and force it return the value 2, instead of 0, when the input strip size is bigger than real. In this way, the tif function TIFFReadEncodedStrip()
 *            will continue to do postprocessing of the already read data.
 *
 *            Special note: in this way, I will have to build a customary libtiff library and install at my own location ~/work/3rdsoft/lib instead of
 *                          the default /usr/local/lib. When I will have to reset the .bashrc/.profile file and use LD_LIBRARY_PATH (and probably also DYLD_LIBRARY_PATH)
 *                          for Mac to link them. This works for the case of V3D already. However, interestingly, I read an article arguing that using otool/ldd/nm, the dependency
 *                          of objects files can be seen, and that Mac uses the absolute path in library dependency, and that LD_LIBRARY_PATH does not work. The
 *                          interesting thing is that after I tried both, I found otool does show the absolute path, but LD_LIBARY_PATH/DYLD_LIBRARY_PATH works!
 *
 * 070819: add several functions to read LSM file thumbnails and middle slice.
 * 071125: update the copy on my G4 Mac so that it use CPP interface to Gene's codes instead of the C interface
 * 080103: add some further verbose printing
 * 20080213: add interface functions to read single slice of a tiff stack, or the respective thumbnail: Note that the lsm and tif interfaces are DIfferent!
 * 20080301: add handling of 12/16 bit LSM
 * 20080302: change the include "basic_memory.h" to .cpp, due to the template instantiation in V3D
 * 20080401: add the ifndef tag as this will often be included in other files
 * 20080828: add file size limitation, so avoid loading too big file that may cause the tif reader to crash
 * 20080930: return the original tiff pixel value but not the automatically scaled down version
 * 20081204: add overload functions to read only a channel of a stack
 * 20090413: add simple MRC file reading and writing
 * 20090802: add raw5d read/write
 * 20100520: try to revise ZZBIG to allow big file, also add fstat check for windows large file size , instead of using fseek and ftell
 * 20100816: add mylib interface, by PHC.
 */


#ifndef __STACKUTIL_CPP__
#define __STACKUTIL_CPP__

//#include "../elementmexheader.h"

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

#include "stackutil-11.h"
#include "basic_memory.cpp" //change basic_memory.h to basic_memory.cpp, 080302

/*
extern "C" {
*/
#include "mg_image_lib11.h"
/*
};
*/

#define b_VERBOSE_PRINT 1
#define ZZBIG 6000 //previous I define it as 1500, so that to limit the sie of an image is at most 1.5G //change 2010-05-21

#ifdef _MSC_VER       //2010-05-21, by PHC
#include <sys/stat.h>
#include <io.h>
#endif


//int b_VERBOSE_PRINT=1;
/* a simple surfix function.*/

char * getSurfix(char *filename)
{
	if (!filename)
		return 0;

	V3DLONG i=0,k=-1;
	while (filename[i]!='\0')
	{
		if (filename[i]=='.')
			k=i;
		i++;
	}

	if (k==-1 || k==i)
		return 0;

	return (filename+k+1);
}


/* The following is the core function for image stack reading of 2 byte raw*/

int loadRaw2Stack_2byte(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype)
{
	/* This function reads 2-4D image stack from raw data generated by the program "saveStack2Raw.m". */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */

	int berror = 0;

	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);

	/* Read header */

	char formatkey[] = "raw_image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	if (fileSize<lenkey+2+4*2+1) /* datatype has 2 bytes, and sz has 4*2 bytes and endian flag has 1 byte. */
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		berror = 1;
		return berror;
	}

	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';

	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	int b_swap = (endianCodeMachine==endianCodeData)?0:1;


	short int dcode = 0;
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);

	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
				berror = 1;
			return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	short int mysz[4];
	fread(mysz, 2, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
	{
		for (i=0;i<4;i++)
			swap2bytes((void *)(mysz+i));
	}

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1;
	for (i=0;i<4;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		totalUnit *= sz[i];
	}

	if (totalUnit*unitSize+4*2+2+1+lenkey != fileSize)
	{
		printf("The input file has a size [%ld bytes] to what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*2+2+lenkey);
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (img) {delete []img; img=0;}
	img = new unsigned char [totalUnit*unitSize];
	if (!img)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}
	nread = fread(img, unitSize, totalUnit, fid);
	if (nread!=totalUnit)
	{
		printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, totalUnit);
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		if (img) {delete []img; img=0;}
		berror = 1;
		return berror;
	}

	/* swap the data bytes if necessary */

	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}


	/* clean and return */

	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid); //bug fix on 060412

	return berror;
}


int loadRaw2Stack_2byte(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, int chan_id_to_load) //overload for convenience to read only 1 channel
{
	/* This function reads 2-4D image stack from raw data generated by the program "saveStack2Raw.m". */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */

	int berror = 0;

	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);

	/* Read header */

	char formatkey[] = "raw_image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	if (fileSize<lenkey+2+4*2+1) /* datatype has 2 bytes, and sz has 4*2 bytes and endian flag has 1 byte. */
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		berror = 1;
		return berror;
	}

	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';

	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	int b_swap = (endianCodeMachine==endianCodeData)?0:1;


	short int dcode = 0;
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);

	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
			berror = 1;
			return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	short int mysz[4];
	fread(mysz, 2, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
	{
		for (i=0;i<4;i++)
			swap2bytes((void *)(mysz+i));
	}

	//081204
	if (chan_id_to_load<0 || chan_id_to_load>=mysz[3])
	{
		printf("The specified chan_id_to_load [=%d] is out of the valid of the image data [=] \n", chan_id_to_load, mysz[3]);
		return (berror=1);
	}

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1, channelUnit=1;
	for (i=0;i<3;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		channelUnit *= sz[i];
	}
	sz[3] = 1; //this must be true in case only one channel is read
	totalUnit = channelUnit*mysz[3];

	if (totalUnit*unitSize+4*2+2+1+lenkey != fileSize)
	{
		printf("The input file has a size [%ld bytes] to what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*2+2+lenkey);
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (img) {delete []img; img=0;}
	img = new unsigned char [channelUnit*unitSize];
	if (!img)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (chan_id_to_load>0) //other no need to call the function
		fseek(fid, channelUnit*chan_id_to_load*unitSize, SEEK_CUR);
	nread = fread(img, unitSize, channelUnit, fid);
	if (nread!=channelUnit)
	{
		printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, channelUnit);
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		if (img) {delete []img; img=0;}
		berror = 1;
		return berror;
	}

	/* swap the data bytes if necessary */

	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<channelUnit; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<channelUnit; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}


	/* clean and return */

	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid); //bug fix on 060412

	return berror;
}


/* The following is the core function for image stack writing of 2-byte raw*/

int saveStack2Raw_2byte(const char * filename, const unsigned char * img, const V3DLONG * sz, int datatype)
{
	/* This function save a data stack to raw file */

	int berror = 0;
	V3DLONG i;

	FILE * fid = fopen(filename, "wb");
	if (!fid)
	{
		printf("Fail to open file for writing.\n");
		berror = 1;
		return berror;
	}

	/* Write header */

	char formatkey[] = "raw_image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	V3DLONG nwrite = fwrite(formatkey, 1, lenkey, fid);
	if (nwrite!=lenkey)
	{
		printf("File write error.\n");
		berror = 1;
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Cannot save data on this machine.\n");
		berror = 1;
		return berror;
	}

	nwrite = fwrite(&endianCodeMachine, 1, 1, fid);
	if (nwrite!=1)
	{
		printf("Error happened in file writing.\n");
		berror = 1;
		return berror;
	}

	//int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	//int b_swap = 0; //for this machine itself, should not swap data.

	short int dcode = (short int)datatype;
	if (dcode!=1 && dcode!=2 && dcode!=4)
	{
		printf("Unrecognized data type code [%d]. This code is not supported in this version.\n", dcode);
		berror = 1;
		return berror;
	}

	//if (b_swap) swap2bytes((void *)&dcode);
	nwrite=fwrite(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (nwrite!=1)
	{
		printf("Writing file error.\n");
		berror = 1;
		return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	short int mysz[4];
	//if (b_swap)  {
	for (i=0;i<4;i++) mysz[i] = (short int) sz[i];
	//swap2bytes((void *)(mysz+i));
	//}
	nwrite = fwrite(mysz, 2, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
if (nwrite!=4)
{
    printf("Writing file error.\n");
    berror = 1;
    return berror;
}

V3DLONG totalUnit = 1;
for (i=0;i<4;i++)
{
    totalUnit *= sz[i];
}

nwrite = fwrite(img, unitSize, totalUnit, fid);
if (nwrite!=totalUnit)
{
    printf("Something wrong in file writing. The program wrote [%ld data points] but the file says there should be [%ld data points].\n", nwrite, totalUnit);
    berror = 1;
    return berror;
}

/* swap the data bytes if necessary */
/*
 if (b_swap==1)
 {
	 if (unitSize==2)
	 {
		 for (i=0;i<totalUnit; i++)
		 {
			 swap2bytes((void *)(img+i*unitSize));
		 }
	 }
	 else if (unitSize==4)
	 {
		 for (i=0;i<totalUnit; i++)
		 {
			 swap4bytes((void *)(img+i*unitSize));
		 }
	 }
 }
 */


/* clean and return */

fclose(fid);

return berror;
}

/* The following is the core function for image stack reading */

int loadRaw2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype) //this is the function of 4-byte raw format.
{
    /* This function reads 2-4D image stack from raw data generated by the program "saveStack2Raw.m". */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n",
		//mexPrintf("size of [V3DLONG]=[%d], [V3DLONG]=[%d] [int]=[%d], [short int]=[%d], [double]=[%d], [float]=[%d]\n",
          sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));
    //printf("\n\n\n");

	int berror = 0;

	/*
#ifdef _MSC_VER
	struct stat stbuf;
	int myfd;
	myfd = open(filename, O_RDONLY);
	if (myfd<0) 
	{
		printf("Fail to use open() for this file. \n");
		berror=1;
		return berror;
	}
	FILE * fid = fdopen(myfd, "rb");
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}
	if (fstat(myfd, &stbuf) == -1)
	{
		printf("Fail to get the file status. \n");
		berror=1;
		return berror;
	}
	V3DLONG fileSize = stbuf.st_size;
#else
*/
	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);
/*
#endiff
*/
	/* Read header */

	char formatkey[] = "raw_image_stack_by_hpeng";
	V3DLONG lenkey = strlen(formatkey);

#ifndef _MSC_VER //added by PHC, 2010-05-21
	if (fileSize<lenkey+2+4*4+1) // datatype has 2 bytes, and sz has 4*4 bytes and endian flag has 1 byte. 
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		printf("The fseek-ftell produces a file size = %ld.", fileSize);
		berror = 1;
		return berror;
	}
#endif

	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';

	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	if (b_VERBOSE_PRINT)
    {
        printf("machine endian=[%c] data endian=[%c] b_swap=%d\n", endianCodeMachine, endianCodeData, b_swap);
    }

	short int dcode = 0;
	
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);
////////////////////////??????????????????????????????
	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
				berror = 1;
			return berror;
	}
  ////??????????????????????????????
	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	//short int mysz[4];
	//V3DLONG mysz[4];//060803
	BIT32_UNIT mysz[4];//060806
	mysz[0]=mysz[1]=mysz[2]=mysz[3]=0;
	int tmpn=fread(mysz, 4, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (tmpn!=4)
	{
		printf("This program only reads [%d] units.\n", tmpn);
		berror=1;
		return berror;
	}
	if (b_swap)
	{
		for (i=0;i<4;i++)
		{
			//swap2bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("mysz raw read unit[%ld]: [%d] ", i, mysz[i]);
			swap4bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("swap unit: [%d][%0x] \n", mysz[i], mysz[i]);
		}
	}

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1;
	for (i=0;i<4;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		totalUnit *= sz[i];
	}

		//mexPrintf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
		//mexPrintf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);

#ifndef _MSC_VER //added by PHC, 2010-05-21
	if ((totalUnit*unitSize+4*4+2+1+lenkey) != fileSize)
	{
		printf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
		printf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
		if (b_VERBOSE_PRINT)
		{
			printf("The read sizes are: %d %d %d %d\n", mysz[0], mysz[1], mysz[2], mysz[3]);
		}
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}
#endif

	if (img) {delete []img; img=0;}
	img = new unsigned char [totalUnit*unitSize];
	if (!img)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

//	V3DLONG c,k,j;
//	V3DLONG head = 4*4+2+1+lenkey;
//	V3DLONG pgsz1=sz[2]*sz[1]*sz[0], pgsz2=sz[1]*sz[0], pgsz3=sz[0];
//	
//	for (c=0;c<sz[3];c++)
//	{
//		for (k=0;k<sz[2]; k++)
//		{
//			for (j=0;j<sz[1]; j++)
//			{
//				for (i = 0; i<sz[0]; i++)
//				{
//					//rewind(fid);
//					//fseek (fid, head+(c * pgsz1 + k *pgsz2 + j*pgsz3+i) *unitSize, SEEK_SET);
//					//ftell(fid);
//					fread(img + (c*pgsz1+k*pgsz2 + j*pgsz3 + i)*unitSize,unitSize,1,fid);
//				}
//			}
//			
//		}
//	}
	
	nread = fread(img, unitSize, totalUnit, fid);/////all image data
	if (nread!=totalUnit)
	{
		printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, totalUnit);
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		if (img) {delete []img; img=0;}
		berror = 1;
		return berror;
	}

	/* swap the data bytes if necessary */

	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}

	/* clean and return */

	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid); //bug fix on 060412

	return berror;
}
int loadRaw2Stack_resamping(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, int resampling_size)
{
	
    /* This function reads 2-4D image stack from raw data generated by the program "saveStack2Raw.m". */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n",
			   //mexPrintf("size of [V3DLONG]=[%d], [V3DLONG]=[%d] [int]=[%d], [short int]=[%d], [double]=[%d], [float]=[%d]\n",
			   sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));
    //printf("\n\n\n");
	
	int berror = 0;
	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}
	
	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);
	/*
	 #endiff
	 */
	/* Read header */
	
	char formatkey[] = "raw_image_stack_by_hpeng";
	V3DLONG lenkey = strlen(formatkey);
	
#ifndef _MSC_VER //added by PHC, 2010-05-21
	if (fileSize<lenkey+2+4*4+1) // datatype has 2 bytes, and sz has 4*4 bytes and endian flag has 1 byte. 
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		printf("The fseek-ftell produces a file size = %ld.", fileSize);
		berror = 1;
		return berror;
	}
#endif
	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	
	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';
	
	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}
	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}
	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}
	int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	if (b_VERBOSE_PRINT)
    {
        printf("machine endian=[%c] data endian=[%c] b_swap=%d\n", endianCodeMachine, endianCodeData, b_swap);
    }
	short int dcode = 0;
	
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);

	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;
			
		case 2:
			datatype = 2;
			break;
			
		case 4:
			datatype = 4;
			break;
			
		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
			berror = 1;
			return berror;
	}
	
	
	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
	

	BIT32_UNIT mysz[4];
	mysz[0]=mysz[1]=mysz[2]=mysz[3]=0;
	int tmpn=fread(mysz, 4, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (tmpn!=4)
	{
		printf("This program only reads [%d] units.\n", tmpn);
		berror=1;
		return berror;
	}
	if (b_swap)
	{
		for (i=0;i<4;i++)
		{
			//swap2bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("mysz raw read unit[%ld]: [%d] ", i, mysz[i]);
			swap4bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("swap unit: [%d][%0x] \n", mysz[i], mysz[i]);
		}
	}
	
	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}
	
	V3DLONG totalUnit = 1;
	for (i=0;i<4;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		totalUnit *= sz[i];
	}
	
	//mexPrintf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
	//mexPrintf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
	
#ifndef _MSC_VER //added by PHC, 2010-05-21
	if ((totalUnit*unitSize+4*4+2+1+lenkey) != fileSize)
	{
		printf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
		printf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
		if (b_VERBOSE_PRINT)
		{
			printf("The read sizes are: %d %d %d %d\n", mysz[0], mysz[1], mysz[2], mysz[3]);
		}
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}
#endif
	/////added by jinzhu 2011-02-14 valentine's day
	
	//V3DLONG tmpw = sz[0]/resampling_size;
	V3DLONG tmpw = sz[0];
	
	V3DLONG tmph = ceil(sz[1]/resampling_size);
	
	V3DLONG tmpz = ceil(sz[2]/resampling_size);
	
	printf("tw=%ld th=%ld tz=%ld\n",tmpw,tmph,tmpz);	
	
	if(img){delete []img;img=0;}
	img = new unsigned char [tmpw*tmph*tmpz*sz[3]*unitSize];
	
	if(!img)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}
	////// (4*4+2+1+lenkey):start dada point
	V3DLONG head = 4*4+2+1+lenkey;
	V3DLONG pgsz1=sz[2]*sz[1]*sz[0], pgsz2=sz[1]*sz[0], pgsz3=sz[0];
	V3DLONG cn = tmpw*tmph*tmpz;
	V3DLONG kn = tmpw*tmph;
	V3DLONG total = tmpw*tmph*tmpz*sz[3];
	//printf("sx=%ld sy=%ld sz=%ld\n",startx,starty,startz);
	//printf("ex=%ld ey=%ld ez=%ld\n",endx,endy,endz);
	V3DLONG count=0;
	V3DLONG c,j,k;
	for (c = 0; c < sz[3]; c++)
	{
		for (k = 1; k < sz[2]-1; k = k+resampling_size) 
		{
			for (j = 1; j< sz[1]-1; j= j+resampling_size)
			{
			//	printf("c = %ld k=%ld j=%ld\n",c,k,j);
				rewind(fid);
				fseek(fid, head+(c*pgsz1 + k*pgsz2 + j*pgsz3)*unitSize, SEEK_SET);
				ftell(fid);	
				V3DLONG kk = ceil(k/resampling_size);
				V3DLONG jj = ceil(j/resampling_size);
				fread(img + (c*cn + kk*kn + jj*tmpw)*unitSize,unitSize,tmpw,fid);
				//printf("kk=%ld jj=%ld\n",kk,jj);

			}
		}
	}
	/* swap the data bytes if necessary */
	
	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<total; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<total; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}
	
	/* clean and return */
	
	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid); 
	
	return berror;
}

int loadRaw2Stack_raw_resamping(char * filename, unsigned char * & img, V3DLONG * & szo, V3DLONG *& sz, int & datatype, int &resampling_size)
{
    /* This function reads 2-4D image stack from raw data generated by the program "saveStack2Raw.m". */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n",
			   //mexPrintf("size of [V3DLONG]=[%d], [V3DLONG]=[%d] [int]=[%d], [short int]=[%d], [double]=[%d], [float]=[%d]\n",
			   sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));
    //printf("\n\n\n");
	
	int berror = 0;
	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}
	
	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);
	/*
	 #endiff
	 */
	/* Read header */
	
	char formatkey[] = "raw_image_stack_by_hpeng";
	V3DLONG lenkey = strlen(formatkey);
	
#ifndef _MSC_VER //added by PHC, 2010-05-21
	if (fileSize<lenkey+2+4*4+1) // datatype has 2 bytes, and sz has 4*4 bytes and endian flag has 1 byte. 
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		printf("The fseek-ftell produces a file size = %ld.", fileSize);
		berror = 1;
		return berror;
	}
#endif
	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	
	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';
	
	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}
	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}
	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}
	int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	if (b_VERBOSE_PRINT)
    {
        printf("machine endian=[%c] data endian=[%c] b_swap=%d\n", endianCodeMachine, endianCodeData, b_swap);
    }
	short int dcode = 0;
	
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);
	
	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;
			
		case 2:
			datatype = 2;
			break;
			
		case 4:
			datatype = 4;
			break;
			
		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
			berror = 1;
			return berror;
	}
	
	
	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
	
	
	BIT32_UNIT mysz[4];
	mysz[0]=mysz[1]=mysz[2]=mysz[3]=0;
	int tmpn=fread(mysz, 4, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (tmpn!=4)
	{
		printf("This program only reads [%d] units.\n", tmpn);
		berror=1;
		return berror;
	}
	if (b_swap)
	{
		for (i=0;i<4;i++)
		{
			//swap2bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("mysz raw read unit[%ld]: [%d] ", i, mysz[i]);
			swap4bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("swap unit: [%d][%0x] \n", mysz[i], mysz[i]);
		}
	}
	
	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}
	
	V3DLONG totalUnit = 1;
	for (i=0;i<4;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		totalUnit *= sz[i];
	}
	
	//mexPrintf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
	//mexPrintf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
	
#ifndef _MSC_VER //added by PHC, 2010-05-21
	if ((totalUnit*unitSize+4*4+2+1+lenkey) != fileSize)
	{
		printf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
		printf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
		if (b_VERBOSE_PRINT)
		{
			printf("The read sizes are: %d %d %d %d\n", mysz[0], mysz[1], mysz[2], mysz[3]);
		}
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}
#endif
	/////added by jinzhu 2011-02-14 valentine's day
	
	//V3DLONG tmpw = sz[0]/resampling_size;
	
	if (szo) {delete []szo; szo=0;}
	szo = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!szo)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}
	
	V3DLONG temsize = (sz[0] > sz[1])? sz[0]:sz[1]; 
	
	//resampling_size = int(temsize / 500);
	
	if (temsize <= 1000) 
	{
		resampling_size = 2;
		
	}else if(1000 < temsize  && temsize<=2000)
	{
		resampling_size = 4;
		
	}else if(2000 < temsize && temsize <=3000)
	{
		resampling_size = 6;
		
	}else if(3000 < temsize && temsize <=4000)
	{
		resampling_size = 8;
		
	}else if(4000 < temsize && temsize <=5000)
	{
		resampling_size = 10;
	}
	else if(5000 < temsize && temsize <=7000)
	{
		resampling_size = 12;
		
	}
	else if(5000 < temsize && temsize <=7000)
	{
		resampling_size = 14;
		
	}
	else if(7000 < temsize && temsize <=9000)
	{
		resampling_size = 16;
	}
	else if(9000 < temsize && temsize <=10000)
	{
		resampling_size = 18;
		
	}else 
	{
		resampling_size = 20;

	}

	
	V3DLONG tmpw = sz[0];
	
	V3DLONG tmph = (sz[1]/resampling_size);
	
	V3DLONG tmpz = (sz[2]/resampling_size);
	
	szo[0]=  tmpw;
	szo[1] = tmph;
	szo[2] = tmpz;
	szo[3] = sz[3];
	
	printf("tw=%ld th=%ld tz=%ld\n",tmpw,tmph,tmpz);
	
	printf("sw=%ld sh=%ld sz=%ld\n",sz[0],sz[1],sz[2]);
	
	if(img){delete []img;img=0;}
	img = new unsigned char [tmpw*tmph*tmpz*sz[3]*unitSize];
	
	if(!img)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}
	////// (4*4+2+1+lenkey):start dada point
	V3DLONG head = 4*4+2+1+lenkey;
	V3DLONG pgsz1=sz[2]*sz[1]*sz[0], pgsz2=sz[1]*sz[0], pgsz3=sz[0];
	V3DLONG cn = tmpw*tmph*tmpz;
	V3DLONG kn = tmpw*tmph;
	V3DLONG total = tmpw*tmph*tmpz*sz[3];
	//printf("sx=%ld sy=%ld sz=%ld\n",startx,starty,startz);
	//printf("ex=%ld ey=%ld ez=%ld\n",endx,endy,endz);
	V3DLONG count=0;
	V3DLONG c,j,k;
//	for (c = 0; c < sz[3]; c++)
//	{
//		for (k = 1; k < sz[2]-1; k = k+resampling_size) 
//		{
//			for (j = 1; j< sz[1]-1; j= j+resampling_size)
//			{
//				//	printf("c = %ld k=%ld j=%ld\n",c,k,j);
//				rewind(fid);
//				fseek(fid, head+(c*pgsz1 + k*pgsz2 + j*pgsz3)*unitSize, SEEK_SET);
//				ftell(fid);	
//				V3DLONG kk = ceil(k/resampling_size);
//				V3DLONG jj = ceil(j/resampling_size);
//				fread(img + (c*cn + kk*kn + jj*tmpw)*unitSize,unitSize,tmpw,fid);
//				//printf("kk=%ld jj=%ld\n",kk,jj);
//				
//			}
//		}
//	}
	for (c = 0; c < sz[3]; c++)
	{
		for (k = 0; k < sz[2]; k = k+resampling_size) 
		{
			for (j = 0; j< sz[1]; j = j+resampling_size)
			{
				
				if(k >=sz[2]){k = sz[2];}
				if(j >=sz[1]){j = sz[1];}
				
				V3DLONG kk = (k/resampling_size);
				V3DLONG jj = (j/resampling_size);
				if(kk >= tmpz){kk = tmpz-1;}
				if(jj >= tmph){jj = tmph-1;}
				//printf(" c=%ld k=%ld j=%ld kk=%ld jj=%ld\n",c,k,j,kk,jj);
				rewind(fid);
				fseek(fid, head+(c*pgsz1 + k*pgsz2 + j*pgsz3)*unitSize, SEEK_SET);
				ftell(fid);	
				fread(img + (c*cn + kk*kn + jj*tmpw)*unitSize,unitSize,tmpw,fid);
			}
		}
	}
	
	
	
	
	/* swap the data bytes if necessary */
	
	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<total; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<total; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}
	
	/* clean and return */
	
	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid); 
	
	return berror;
}



int loadRaw2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, V3DLONG startx, V3DLONG starty, V3DLONG startz, 
				  V3DLONG endx,V3DLONG endy, V3DLONG endz, int & datatype) //this is the function of 4-byte raw format.
{
	
	printf("startx=%ld starty=%ld startz=%ld endx=%ld endy=%ld endz=%ld\n",startx,starty,startz,endx,endy,endz);	
	
	
    /* This function reads 2-4D image stack from raw data generated by the program "saveStack2Raw.m". */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n",
			   //mexPrintf("size of [V3DLONG]=[%d], [V3DLONG]=[%d] [int]=[%d], [short int]=[%d], [double]=[%d], [float]=[%d]\n",
			   sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));
    //printf("\n\n\n");
	
	int berror = 0;
		FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}
	
	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);
	/*
	 #endiff
	 */
	/* Read header */
	//printf("1111111111111111111111111111111111111111111 ");
	
	char formatkey[] = "raw_image_stack_by_hpeng";
	V3DLONG lenkey = strlen(formatkey);
	
#ifndef _MSC_VER //added by PHC, 2010-05-21
	if (fileSize<lenkey+2+4*4+1) // datatype has 2 bytes, and sz has 4*4 bytes and endian flag has 1 byte. 
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		printf("The fseek-ftell produces a file size = %ld.", fileSize);
		berror = 1;
		return berror;
	}
#endif
//	printf("111111112222222222222222222 ");
	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	
//   printf("111111113333333333333333333333333 ");
	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';
	
	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}
	// printf("1111111144444444444444444444444444444444 ");
	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}
//	printf("111111115555555555555555555555555 ");
	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}
//	printf("111111116666666666666666666666 ");
	int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	if (b_VERBOSE_PRINT)
    {
        printf("machine endian=[%c] data endian=[%c] b_swap=%d\n", endianCodeMachine, endianCodeData, b_swap);
    }
//	printf("22222222222222222222222222222222222222 ");
	
	short int dcode = 0;
	
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);
	////////////////////////??????????????????????????????
	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;
			
		case 2:
			datatype = 2;
			break;
			
		case 4:
			datatype = 4;
			break;
			
		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
			berror = 1;
			return berror;
	}
	
	//printf("33333333333333333333333333333333333333333333333 ");
	
	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
	
	//short int mysz[4];
	//V3DLONG mysz[4];//060803
	BIT32_UNIT mysz[4];//060806
	mysz[0]=mysz[1]=mysz[2]=mysz[3]=0;
	int tmpn=fread(mysz, 4, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (tmpn!=4)
	{
		printf("This program only reads [%d] units.\n", tmpn);
		berror=1;
		return berror;
	}
	if (b_swap)
	{
		for (i=0;i<4;i++)
		{
			//swap2bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("mysz raw read unit[%ld]: [%d] ", i, mysz[i]);
			swap4bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("swap unit: [%d][%0x] \n", mysz[i], mysz[i]);
		}
	}
	
	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}
	
	V3DLONG totalUnit = 1;
	for (i=0;i<4;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		totalUnit *= sz[i];
	}
	
	//mexPrintf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
	//mexPrintf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
	
#ifndef _MSC_VER //added by PHC, 2010-05-21
	if ((totalUnit*unitSize+4*4+2+1+lenkey) != fileSize)
	{
		printf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
		printf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
		if (b_VERBOSE_PRINT)
		{
			printf("The read sizes are: %d %d %d %d\n", mysz[0], mysz[1], mysz[2], mysz[3]);
		}
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}
#endif
/////added by jinzhu 2011-02-09
	
	V3DLONG tmpw = endx - startx;
	V3DLONG tmph = endy - starty;
	V3DLONG tmpz = endz - startz;
	//printf("to=%ld yt=%ld zto=%ld\n",tmpw,tmph,tmpz);	
	if(img){delete []img;img=0;}
	img = new unsigned char [tmpw*tmph*tmpz*sz[3]*unitSize];
	if(!img)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}
	////// (4*4+2+1+lenkey):start dada point
	V3DLONG head = 4*4+2+1+lenkey;
	V3DLONG pgsz1=sz[2]*sz[1]*sz[0], pgsz2=sz[1]*sz[0], pgsz3=sz[0];
	V3DLONG cn = tmpw*tmph*tmpz;
	V3DLONG kn = tmpw*tmph;
	V3DLONG total = tmpw*tmph*tmpz*sz[3];
	//printf("sx=%ld sy=%ld sz=%ld\n",startx,starty,startz);
	//printf("ex=%ld ey=%ld ez=%ld\n",endx,endy,endz);
	V3DLONG count=0;
	V3DLONG c,j,k;
	for (c = 0; c < sz[3]; c++)
	{
		for (k = startz; k < endz; k++) 
		{
			for (j = starty; j< endy; j++)
			{
				rewind(fid);
				fseek(fid, head+(c*pgsz1 + k*pgsz2 + j*pgsz3 + startx)*unitSize, SEEK_SET);
				ftell(fid);	
				fread(img+(c*cn+(k-startz)*kn + (j-starty)*tmpw)*unitSize,unitSize,tmpw,fid);
			}
		}
	}

	/* swap the data bytes if necessary */
	
	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<total; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<total; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}

	
	/* clean and return */
	
	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid); 
	
	return berror;
}
int get_channel_point(FILE * fid,V3DLONG head,V3DLONG channelid, V3DLONG sx, V3DLONG sy, V3DLONG sz,V3DLONG sc,V3DLONG unitSize)
{
	rewind(fid);
	fseek (fid, head, SEEK_SET);
	ftell(fid);
	fseek (fid, (channelid * sx*sy*sz)*unitSize, SEEK_CUR);
	ftell(fid);	
}
int get_zslice_point(FILE * fid,V3DLONG head,V3DLONG channelid, V3DLONG zid, V3DLONG sx, V3DLONG sy, V3DLONG sz,V3DLONG sc,V3DLONG unitSize)
{
	rewind(fid);
	fseek (fid, head, SEEK_SET);
	ftell(fid);
	fseek (fid, (channelid * sx*sy*sz + zid *sx*sy) *unitSize, SEEK_CUR);
	ftell(fid);	
}
int get_c_z_y_point(FILE * fid,V3DLONG head,V3DLONG channelid, V3DLONG zid,V3DLONG yid, V3DLONG sx, V3DLONG sy, V3DLONG sz,V3DLONG sc,V3DLONG unitSize)
{
	rewind(fid);
	fseek (fid, head, SEEK_SET);
	ftell(fid);
	fseek (fid, (channelid * sx*sy*sz + zid *sx*sy + yid *sx) *unitSize, SEEK_CUR);
	ftell(fid);	
}
int get_c_z_y_x_point(FILE * fid,V3DLONG head,V3DLONG channelid, V3DLONG zid,V3DLONG yid,V3DLONG xid, V3DLONG sx, V3DLONG sy, V3DLONG sz,V3DLONG sc,V3DLONG unitSize)
{
	rewind(fid);
	fseek (fid, head, SEEK_SET);
	ftell(fid);
	fseek (fid, (channelid * sx*sy*sz + zid *sx*sy + yid *sx + xid) *unitSize, SEEK_CUR);
	ftell(fid);	
}
int loadRaw2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, int chan_id_to_load) //this is the function of 4-byte raw format.
{
    /* This function reads 2-4D image stack from raw data generated by the program "saveStack2Raw.m". */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n",
			   //mexPrintf("size of [V3DLONG]=[%d], [V3DLONG]=[%d] [int]=[%d], [short int]=[%d], [double]=[%d], [float]=[%d]\n",
			   sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));
    //printf("\n\n\n");

	int berror = 0;

	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);

	/* Read header */

	char formatkey[] = "raw_image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	if (fileSize<lenkey+2+4*4+1) /* datatype has 2 bytes, and sz has 4*4 bytes and endian flag has 1 byte. */
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		berror = 1;
		return berror;
	}

	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';

	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	if (b_VERBOSE_PRINT)
    {
        printf("machine endian=[%c] data endian=[%c] b_swap=%d\n", endianCodeMachine, endianCodeData, b_swap);
    }


	short int dcode = 0;
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);

	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
			berror = 1;
			return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	//short int mysz[4];
	//V3DLONG mysz[4];//060803
	BIT32_UNIT mysz[4];//060806
	mysz[0]=mysz[1]=mysz[2]=mysz[3]=0;
	int tmpn=fread(mysz, 4, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (tmpn!=4)
	{
		printf("This program only reads [%d] units.\n", tmpn);
		berror=1;
		return berror;
	}
	if (b_swap)
	{
		for (i=0;i<4;i++)
		{
			//swap2bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("mysz raw read unit[%ld]: [%d] ", i, mysz[i]);
			swap4bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("swap unit: [%d][%0x] \n", mysz[i], mysz[i]);
		}
	}

	//081204
	if (chan_id_to_load<0 || chan_id_to_load>=mysz[3])
	{
		printf("The specified chan_id_to_load [=%d] is out of the valid of the image data [=] \n", chan_id_to_load, mysz[3]);
		return (berror=1);
	}

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1, channelUnit=1;
	for (i=0;i<3;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		channelUnit *= sz[i];
	}
	sz[3] = 1; //this must be true in case only one channel is read
	totalUnit = channelUnit*mysz[3];

	//mexPrintf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
	//mexPrintf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
	if ((totalUnit*unitSize+4*4+2+1+lenkey) != fileSize)
	{
		printf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
		printf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
		if (b_VERBOSE_PRINT)
		{
			printf("The read sizes are: %d %d %d %d\n", mysz[0], mysz[1], mysz[2], mysz[3]);
		}
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (img) {delete []img; img=0;}
	img = new unsigned char [channelUnit*unitSize];
	if (!img)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (chan_id_to_load>0) //other no need to call the function
		fseek(fid, channelUnit*chan_id_to_load*unitSize, SEEK_CUR);
	nread = fread(img, unitSize, channelUnit, fid);
	if (nread!=channelUnit)
	{
		printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, channelUnit);
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		if (img) {delete []img; img=0;}
		berror = 1;
		return berror;
	}

	/* swap the data bytes if necessary */

	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<channelUnit; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<channelUnit; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}


	/* clean and return */

	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid); //bug fix on 060412

	return berror;
}
/* The following is the core function for image stack writing */

int saveStack2Raw(const char * filename, const unsigned char * img, const V3DLONG * sz, int datatype)
{
	/* This function save a data stack to raw file */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n", sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));

	int berror = 0;
	V3DLONG i;

	FILE * fid = fopen(filename, "wb");
	if (!fid)
	{
		printf("Fail to open file for writing.\n");
		berror = 1;
		return berror;
	}

	/* Write header */

	char formatkey[] = "raw_image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	V3DLONG nwrite = fwrite(formatkey, 1, lenkey, fid);
	if (nwrite!=lenkey)
	{
		printf("File write error.\n");
		berror = 1;
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Cannot save data on this machine.\n");
		berror = 1;
		return berror;
	}

	nwrite = fwrite(&endianCodeMachine, 1, 1, fid);
	if (nwrite!=1)
	{
		printf("Error happened in file writing.\n");
		berror = 1;
		return berror;
	}

	//int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	//int b_swap = 0; //for this machine itself, should not swap data.

	short int dcode = (short int)datatype;
	if (dcode!=1 && dcode!=2 && dcode!=4)
	{
		printf("Unrecognized data type code [%d]. This code is not supported in this version.\n", dcode);
		berror = 1;
		return berror;
	}

	//if (b_swap) swap2bytes((void *)&dcode);
	nwrite=fwrite(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (nwrite!=1)
	{
		printf("Writing file error.\n");
		berror = 1;
		return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	//short int mysz[4];
	BIT32_UNIT mysz[4];//060806
					   //if (b_swap)  {
					   //for (i=0;i<4;i++) mysz[i] = (short int) sz[i];
		for (i=0;i<4;i++) mysz[i] = (BIT32_UNIT) sz[i];
		//swap2bytes((void *)(mysz+i));
		//}
		nwrite = fwrite(mysz, 4, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (nwrite!=4)
	{
		printf("Writing file error.\n");
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1;
	for (i=0;i<4;i++)
	{
		totalUnit *= sz[i];
	}

	nwrite = fwrite(img, unitSize, totalUnit, fid);
	if (nwrite!=totalUnit)
	{
		printf("Something wrong in file writing. The program wrote [%ld data points] but the file says there should be [%ld data points].\n", nwrite, totalUnit);
		berror = 1;
		return berror;
	}

	/* clean and return */

	fclose(fid);

	return berror;
}


int loadRaw5d2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype)
{
    /* This function reads 2-5D image stack from v3d raw5 data */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n",
			   //mexPrintf("size of [V3DLONG]=[%d], [V3DLONG]=[%d] [int]=[%d], [short int]=[%d], [double]=[%d], [float]=[%d]\n",
			   sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));
    //printf("\n\n\n");

	int berror = 0;

	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);

	/* Read header */

	char formatkey[] = "raw5image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	if (fileSize<lenkey+2+4*5+1) /* datatype has 2 bytes, and sz has 4*4 bytes and endian flag has 1 byte. */
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		berror = 1;
		return berror;
	}

	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';

	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	if (b_VERBOSE_PRINT)
    {
        printf("machine endian=[%c] data endian=[%c] b_swap=%d\n", endianCodeMachine, endianCodeData, b_swap);
    }


	short int dcode = 0;
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);

	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
			berror = 1;
			return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	BIT32_UNIT mysz[5];
	mysz[0]=mysz[1]=mysz[2]=mysz[3]=mysz[4]=0;
	int tmpn=fread(mysz, 4, 5, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (tmpn!=5)
	{
		printf("This program only reads [%d] units.\n", tmpn);
		berror=1;
		return berror;
	}
	if (b_swap)
	{
		for (i=0;i<5;i++)
		{
			if (b_VERBOSE_PRINT)
				printf("mysz raw read unit[%ld]: [%d] ", i, mysz[i]);
			swap4bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("swap unit: [%d][%0x] \n", mysz[i], mysz[i]);
		}
	}

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [5]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1;
	for (i=0;i<5;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		totalUnit *= sz[i];
	}

	//mexPrintf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
	//mexPrintf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
	if ((totalUnit*unitSize+4*5+2+1+lenkey) != fileSize)
	{
		printf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*5+2+1+lenkey);
		printf("The read sizes are: %ld %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3], sz[4]);
		if (b_VERBOSE_PRINT)
		{
			printf("The read sizes are: %d %d %d %d %d\n", mysz[0], mysz[1], mysz[2], mysz[3], mysz[4]);
		}
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (img) {delete []img; img=0;}
	img = new unsigned char [totalUnit*unitSize];
	if (!img)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	nread = fread(img, unitSize, totalUnit, fid);
	if (nread!=totalUnit)
	{
		printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, totalUnit);
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		if (img) {delete []img; img=0;}
		berror = 1;
		return berror;
	}

	/* swap the data bytes if necessary */

	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}


	/* clean and return */

	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid); //bug fix on 060412

	return berror;
}

int loadRaw5d2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, int stack_id_to_load)
{
    /* This function reads 2-5D image stack from v3d raw5 data . */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n",
			   //mexPrintf("size of [V3DLONG]=[%d], [V3DLONG]=[%d] [int]=[%d], [short int]=[%d], [double]=[%d], [float]=[%d]\n",
			   sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));
    //printf("\n\n\n");

	int berror = 0;

	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);

	/* Read header */

	char formatkey[] = "raw5image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	if (fileSize<lenkey+2+4*5+1) /* datatype has 2 bytes, and sz has 4*4 bytes and endian flag has 1 byte. */
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		berror = 1;
		return berror;
	}

	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';

	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	if (b_VERBOSE_PRINT)
    {
        printf("machine endian=[%c] data endian=[%c] b_swap=%d\n", endianCodeMachine, endianCodeData, b_swap);
    }


	short int dcode = 0;
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);

	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
			berror = 1;
			return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	BIT32_UNIT mysz[5];
	mysz[0]=mysz[1]=mysz[2]=mysz[3]=mysz[4]=0;
	int tmpn=fread(mysz, 4, 5, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (tmpn!=4)
	{
		printf("This program only reads [%d] units.\n", tmpn);
		berror=1;
		return berror;
	}
	if (b_swap)
	{
		for (i=0;i<5;i++)
		{
			if (b_VERBOSE_PRINT)
				printf("mysz raw read unit[%ld]: [%d] ", i, mysz[i]);
			swap4bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("swap unit: [%d][%0x] \n", mysz[i], mysz[i]);
		}
	}

	if (stack_id_to_load<0 || stack_id_to_load>=mysz[4])
	{
		printf("The specified stack_id_to_load [=%d] is out of the valid of the image data [=] \n", stack_id_to_load, mysz[4]);
		return (berror=1);
	}

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [5]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1, stackUnit=1;
	for (i=0;i<4;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		stackUnit *= sz[i];
	}
	sz[4] = 1; //this must be true in case only one channel is read
	totalUnit = stackUnit*mysz[4];

	if ((totalUnit*unitSize+4*5+2+1+lenkey) != fileSize)
	{
		printf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*5+2+1+lenkey);
		printf("The read sizes are: %ld %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3], sz[4]);
		if (b_VERBOSE_PRINT)
		{
			printf("The read sizes are: %d %d %d %d %d\n", mysz[0], mysz[1], mysz[2], mysz[3], mysz[4]);
		}
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (img) {delete []img; img=0;}
	img = new unsigned char [stackUnit*unitSize];
	if (!img)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (stack_id_to_load>0) //other no need to call the function
		fseek(fid, stackUnit*stack_id_to_load*unitSize, SEEK_CUR);
	nread = fread(img, unitSize, stackUnit, fid);
	if (nread!=stackUnit)
	{
		printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, stackUnit);
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		if (img) {delete []img; img=0;}
		berror = 1;
		return berror;
	}

	/* swap the data bytes if necessary */

	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<stackUnit; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<stackUnit; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}


	/* clean and return */

	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid);

	return berror;
}

int saveStack2Raw5d(const char * filename, const unsigned char * img, const V3DLONG * sz, int datatype)
{
	/* This function save a data stack to raw file */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n", sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));

	int berror = 0;
	V3DLONG i;

	FILE * fid = fopen(filename, "wb");
	if (!fid)
	{
		printf("Fail to open file for writing.\n");
		berror = 1;
		return berror;
	}

	/* Write header */

	char formatkey[] = "raw5image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	V3DLONG nwrite = fwrite(formatkey, 1, lenkey, fid);
	if (nwrite!=lenkey)
	{
		printf("File write error.\n");
		berror = 1;
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Cannot save data on this machine.\n");
		berror = 1;
		return berror;
	}

	nwrite = fwrite(&endianCodeMachine, 1, 1, fid);
	if (nwrite!=1)
	{
		printf("Error happened in file writing.\n");
		berror = 1;
		return berror;
	}

	//int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	//int b_swap = 0; //for this machine itself, should not swap data.

	short int dcode = (short int)datatype;
	if (dcode!=1 && dcode!=2 && dcode!=4)
	{
		printf("Unrecognized data type code [%d]. This code is not supported in this version.\n", dcode);
		berror = 1;
		return berror;
	}

	//if (b_swap) swap2bytes((void *)&dcode);
	nwrite=fwrite(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (nwrite!=1)
	{
		printf("Writing file error.\n");
		berror = 1;
		return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	BIT32_UNIT mysz[5];//090802
	for (i=0;i<5;i++) mysz[i] = (BIT32_UNIT) sz[i];
	nwrite = fwrite(mysz, 4, 5, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (nwrite!=5)
	{
		printf("Writing file error.\n");
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1;
	for (i=0;i<5;i++)
	{
		totalUnit *= sz[i];
	}

	nwrite = fwrite(img, unitSize, totalUnit, fid);
	if (nwrite!=totalUnit)
	{
		printf("Something wrong in file writing. The program wrote [%ld data points] but the file says there should be [%ld data points].\n", nwrite, totalUnit);
		berror = 1;
		return berror;
	}

	/* clean and return */

	fclose(fid);

	return berror;
}


/* check the machine endianness */

char checkMachineEndian()
{
    char e='N'; //for unknown endianness

    V3DLONG int a=0x44332211;
    unsigned char * p = (unsigned char *)&a;
    if ((*p==0x11) && (*(p+1)==0x22) && (*(p+2)==0x33) && (*(p+3)==0x44))
        e = 'L';
    else if ((*p==0x44) && (*(p+1)==0x33) && (*(p+2)==0x22) && (*(p+3)==0x11))
        e = 'B';
    else if ((*p==0x22) && (*(p+1)==0x11) && (*(p+2)==0x44) && (*(p+3)==0x33))
        e = 'M';
    else
        e = 'N';

    //printf("[%c] \n", e);
    return e;
}


void swap2bytes(void *targetp)
{
    unsigned char * tp = (unsigned char *)targetp;
    unsigned char a = *tp;
    *tp = *(tp+1);
    *(tp+1) = a;
}

void swap4bytes(void *targetp)
{
    unsigned char * tp = (unsigned char *)targetp;
    unsigned char a = *tp;
    *tp = *(tp+3);
    *(tp+3) = a;
    a = *(tp+1);
    *(tp+1) = *(tp+2);
    *(tp+2) = a;
}


int loadTif2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, int chan_id_to_load) //overload for convenience to read only 1 channel
{
	if (chan_id_to_load<0) {fprintf(stderr, "Chan_id_to_load < 0. Do nothing\n"); int b_error=1; return b_error;}
	int val_return = loadTif2Stack(filename, img, sz, datatype);
	if (chan_id_to_load>=sz[3]) {fprintf(stderr, "Chan_id_to_load > # of data color channels. force chan_id_to_load to be the last channel\n"); chan_id_to_load=sz[3]-1;}
	if (sz[3]==1) return val_return;
	else
	{
		V3DLONG chanel_bytes = V3DLONG(sz[0])*sz[1]*sz[2]*datatype;
		if (chan_id_to_load>0) //otherwise no need to do this
			memcpy(img, img+chanel_bytes*chan_id_to_load, chanel_bytes);
		realloc(img, chanel_bytes); //shrink download the memory used
		sz[3]=1;
		return val_return;
	}
}

int loadLsm2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, int chan_id_to_load)   //overload for convenience to read only 1 channel
{
	if (chan_id_to_load<0) {fprintf(stderr, "Chan_id_to_load < 0. Do nothing\n"); int b_error=1; return b_error;}
	int val_return = loadLsm2Stack(filename, img, sz, datatype);
	if (chan_id_to_load>=sz[3]) {fprintf(stderr, "Chan_id_to_load > # of data color channels. force chan_id_to_load to be the last channel\n"); chan_id_to_load=sz[3]-1;}
	if (sz[3]==1) return val_return;
	else
	{
		V3DLONG chanel_bytes = V3DLONG(sz[0])*sz[1]*sz[2]*datatype;
		if (chan_id_to_load>0) //otherwise no need to do this
			memcpy(img, img+chanel_bytes*chan_id_to_load, chanel_bytes);
		realloc(img, chanel_bytes); //shrink download the memory used
		sz[3]=1;
		return val_return;
	}
}

int loadTif2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype)
{
	int b_error=0;

	//fprintf(stderr, "Verify file existence.\n");
	FILE *tmp = fopen(filename, "r");
	if (!tmp) {fprintf(stderr, "The file [%s] does not exist.\n", filename); b_error=1; return b_error;}
	else {fclose(tmp);}

	//the following are the interface codes

	Stack *tmpstack = Read_Stack(filename);
	if (!tmpstack)
	{
		b_error=1;
		return b_error;
	}

	//convert to hanchuan's format
	if (sz) {delete sz; sz=0;}
	if (img) {delete img; img=0;}

	sz=new V3DLONG [4];
	if (sz)
	{
		sz[0] = tmpstack->width;
		sz[1] = tmpstack->height;
		sz[2] = tmpstack->depth;
		switch (tmpstack->kind)
		{
			case GREY:
				sz[3] = 1;
				datatype = 1;
				break;

			case GREY16:
				sz[3] = 1;
				datatype = 2;
				break;

			case COLOR:
				sz[3] = 3;
				datatype = 1;
				break;

			default:
				printf("The type of tif file is not supported in this version.\n");
				if (sz) {delete sz; sz=0;}
					Kill_Stack(tmpstack); tmpstack=0;
				break;
		}
	}
	else
	{
		printf("Unable to allocate memory for the size varable! Return.\n");
		if (tmpstack)
		{
			Kill_Stack(tmpstack);
			tmpstack=0;
		}
		b_error=1;
		return b_error;
	}

	img = new unsigned char [sz[0]*sz[1]*sz[2]*sz[3]*datatype];
	if (!img)
	{
		printf("Unable to allocate memory for the image varable! Return.\n");
		if (tmpstack)	  {	Kill_Stack(tmpstack);	tmpstack=0;}
		if (sz) {delete sz; sz=0;}
		b_error=1;
		return b_error;
	}
	else
	{
		V3DLONG i,j,k,c;
		V3DLONG pgsz1=sz[2]*sz[1]*sz[0], pgsz2=sz[1]*sz[0], pgsz3=sz[0];

		switch (tmpstack->kind)
		{
			case GREY:
			case COLOR:
				for (c=0;c<sz[3];c++)
					for (k=0;k<sz[2]; k++)
						for (j=0;j<sz[1]; j++)
							for (i=0;i<sz[0]; i++)
								//img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = STACK_PIXEL_8(tmpstack,i,j,k,c);
								img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = Get_Stack_Pixel(tmpstack,i,j,k,c);

				break;

			case GREY16:
				{
					unsigned short int *img16 = (unsigned short int *)img;
					for (c=0;c<sz[3];c++)
						for (k=0;k<sz[2]; k++)
							for (j=0;j<sz[1]; j++)
								for (i=0;i<sz[0]; i++)
									//img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = STACK_PIXEL_16(tmpstack,i,j,k,c)>>4; //assume it is 12-bit
									//img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = Get_Stack_Pixel(tmpstack,i,j,k,c)>>4; //assume it is 12-bit
									img16[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = Get_Stack_Pixel(tmpstack,i,j,k,c); //do not assume anything. 080930
				}

				break;

			default:
				printf("The type of tif file is not supported in this version.\n");
				if (sz) {delete sz; sz=0;}
					if (img) {delete img; img=0;}
					Kill_Stack(tmpstack); tmpstack=0;
				b_error=1;
				return b_error;
				break;
		}
	}


	// kill stack
	if (tmpstack)
	{
		Kill_Stack(tmpstack);
		tmpstack=0;
	}

	return b_error;

}
int loadTif2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, V3DLONG startx, V3DLONG starty, V3DLONG startz, 
				  V3DLONG endx,V3DLONG endy,V3DLONG endz,int & datatype)
{
	int b_error=0;
	
	//fprintf(stderr, "Verify file existence.\n");
	FILE *tmp = fopen(filename, "r");
	if (!tmp) {fprintf(stderr, "The file [%s] does not exist.\n", filename); b_error=1; return b_error;}
	else {fclose(tmp);}
	
	//the following are the interface codes
	
//	Stack *tmpstack = Read_Stack(filename);
	Stack *tmpstack = Read_Stack_location(filename,startz,endz);
	
	if (!tmpstack)
	{
		b_error=1;
		return b_error;
	}
	
	//convert to hanchuan's format
	if (sz) {delete sz; sz=0;}
	if (img) {delete img; img=0;}
	
	sz=new V3DLONG [4];
	if (sz)
	{
		sz[0] = tmpstack->width;
		sz[1] = tmpstack->height;
		sz[2] = tmpstack->depth;
		
		switch (tmpstack->kind)
		{
			case GREY:
				sz[3] = 1;
				datatype = 1;
				break;
				
			case GREY16:
				sz[3] = 1;
				datatype = 2;
				break;
				
			case COLOR:
				sz[3] = 3;
				datatype = 1;
				break;
				
			default:
				printf("The type of tif file is not supported in this version.\n");
				if (sz) {delete sz; sz=0;}
				Kill_Stack(tmpstack); tmpstack=0;
				break;
		}
	}
	else
	{
		printf("Unable to allocate memory for the size varable! Return.\n");
		if (tmpstack)
		{
			Kill_Stack(tmpstack);
			tmpstack=0;
		}
		b_error=1;
		return b_error;
	}
	
	V3DLONG vx = endx - startx;
	V3DLONG vy = endy - starty;
	V3DLONG vz = sz[2];
	//img = new unsigned char [sz[0]*sz[1]*sz[2]*sz[3]*datatype];
	//img = new unsigned char [sz[0]*sz[1]*vz*sz[3]*datatype];
	img = new unsigned char [vx*vy*vz*sz[3]*datatype];
	
	if (!img)
	{
		printf("Unable to allocate memory for the image varable! Return.\n");
		if (tmpstack)	  {	Kill_Stack(tmpstack);	tmpstack=0;}
		if (sz) {delete sz; sz=0;}
		b_error=1;
		return b_error;
	}
	else
	{
		V3DLONG i,j,k,c;
		
	//	V3DLONG pgsz1=sz[2]*sz[1]*sz[0], pgsz2=sz[1]*sz[0], pgsz3=sz[0];
	    
		V3DLONG pgsz1=vx*vy*vz, pgsz2=vy*vx, pgsz3=vx;	
		
		switch (tmpstack->kind)
		{
			case GREY:
			case COLOR:
				for (c=0;c<sz[3];c++)
					for (k=0;k<sz[2]; k++)
						for (j=starty;j<endy; j++)
							for (i=startx;i<endx; i++)
								//img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = STACK_PIXEL_8(tmpstack,i,j,k,c);
								img[c*pgsz1 + k*pgsz2 + (j-starty)*pgsz3 + (i-startx)] = Get_Stack_Pixel(tmpstack,i,j,k,c);
				
				break;
				
			case GREY16:
			{
				unsigned short int *img16 = (unsigned short int *)img;
				for (c=0;c<sz[3];c++)
					for (k=0;k<sz[2]; k++)
						for (j=starty; j< endy; j++)
							for (i=startx; i< endx; i++)
								//img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = STACK_PIXEL_16(tmpstack,i,j,k,c)>>4; //assume it is 12-bit
								//img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = Get_Stack_Pixel(tmpstack,i,j,k,c)>>4; //assume it is 12-bit
								img16[c*pgsz1 + k*pgsz2 + (j-starty)*pgsz3 + (i-startx)] = Get_Stack_Pixel(tmpstack,i,j,k,c); //do not assume anything. 080930
			}
				
				break;
				
			default:
				printf("The type of tif file is not supported in this version.\n");
				if (sz) {delete sz; sz=0;}
				if (img) {delete img; img=0;}
				Kill_Stack(tmpstack); tmpstack=0;
				b_error=1;
				return b_error;
				break;
		}
		//V3DLONG pgsz1=vx*vy*vz, pgsz2=vy*vx, pgsz3=vx;

//		switch (tmpstack->kind)
//		{
//			case GREY:
//			case COLOR:
//				for (c=0;c<sz[3];c++)
//					for (k=0;k<sz[2]; k++)
//						for (j=0;j<sz[1]; j++)
//							for (i=0;i<sz[0]; i++)
//								//img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = STACK_PIXEL_8(tmpstack,i,j,k,c);
//								img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = Get_Stack_Pixel(tmpstack,i,j,k,c);
//				
//				break;
//				
//			case GREY16:
//			{
//				unsigned short int *img16 = (unsigned short int *)img;
//				for (c=0;c<sz[3];c++)
//					for (k=0;k<sz[2]; k++)
//						for (j=0;j<sz[1]; j++)
//							for (i=0;i<sz[0]; i++)
//								//img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = STACK_PIXEL_16(tmpstack,i,j,k,c)>>4; //assume it is 12-bit
//								//img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = Get_Stack_Pixel(tmpstack,i,j,k,c)>>4; //assume it is 12-bit
//								img16[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = Get_Stack_Pixel(tmpstack,i,j,k,c); //do not assume anything. 080930
//			}
//				
//				break;
//				
//			default:
//				printf("The type of tif file is not supported in this version.\n");
//				if (sz) {delete sz; sz=0;}
//				if (img) {delete img; img=0;}
//				Kill_Stack(tmpstack); tmpstack=0;
//				b_error=1;
//				return b_error;
//				break;
//		}
	}
	
	
	// kill stack
	if (tmpstack)
	{
		Kill_Stack(tmpstack);
		tmpstack=0;
	}
	
	return b_error;
	
}


int saveStack2Tif(const char * filename, const unsigned char * img, const V3DLONG * sz, int datatype)
{
	int b_error=0;

	int i,j,k,c;
	for (i=0;i<4;i++)
	{
		if (sz[i]<0)
		{
			printf("The %d sz parameter is not valid [%ld]. Exit.\n", i, sz[i]);
			b_error=1;
			return b_error;
		}
	}

	if (!img)
	{
		printf("The input image pointer is null. Exit.\n");
		b_error=1;
		return b_error;
	}

	int kind;
	if (sz[3]==1)
		kind = GREY;
	else //if (sz[3]>1) //but only output the 3 first channels
		kind = COLOR;

	Stack *tmpstack = Make_Stack(kind, int(sz[0]), int(sz[1]), int(sz[2]));
	if (!tmpstack)
	{
		printf("Fail to allocate memory for tif output.\n");
		b_error=1;
		return b_error;
	}

	V3DLONG pgsz1=sz[2]*sz[1]*sz[0], pgsz2=sz[1]*sz[0], pgsz3=sz[0];
	for (c=0;c<sz[3];c++)
		for (k=0;k<sz[2]; k++)
			for (j=0;j<sz[1]; j++)
				for (i=0;i<sz[0]; i++)
					Set_Stack_Pixel(tmpstack,i,j,k,c, img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i]);

	//output to file
	Write_Stack((char*)filename, tmpstack);

	// kill stack
	if (tmpstack)
	{
		Kill_Stack(tmpstack);
		tmpstack=0;
	}

	return b_error;
}


int loadLsm2Stack_obsolete(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype) //070713
{
	int b_error=0;

	//070306: verify the file exists: Note that for some reasons, the printf() output does not show up in Matlab (mex file) but completely normal for other C executable (like laff). Strange.

	//fprintf(stderr, "Verify file existence.\n");
	FILE *tmp = fopen(filename, "r");
	if (!tmp) {fprintf(stderr, "The file [%s] does not exist.\n", filename); b_error=1; return b_error;}
	else {fclose(tmp);}


	//the following are the interface codes

	Stack *tmpstack = Read_LSM_Stack(filename);
	if (!tmpstack)
	{
		b_error=1;
		return b_error;
	}

	//convert to hanchuan's format
	if (sz) {delete sz; sz=0;}
	if (img) {delete img; img=0;}

	sz=new V3DLONG [4];
	if (sz)
	{
		sz[0] = tmpstack->width;
		sz[1] = tmpstack->height;
		sz[2] = tmpstack->depth;
		switch (tmpstack->kind)
		{
			case GREY:
				sz[3] = 1;
				datatype = 1;
				break;

			case GREY16:
				sz[3] = 1;
				datatype = 1;
				break;

			case COLOR:
				sz[3] = 3;
				datatype = 1;
				break;

			default:
				printf("The type of tif file is not supported in this version.\n");
				if (sz) {delete sz; sz=0;}
					Kill_Stack(tmpstack); tmpstack=0;
				break;
		}
	}
	else
	{
		printf("Unable to allocate memory for the size varable! Return.\n");
		if (tmpstack)
		{
			Kill_Stack(tmpstack);
			tmpstack=0;
		}
		b_error=1;
		return b_error;
	}

	img = new unsigned char [sz[0]*sz[1]*sz[2]*sz[3]];
	if (!img)
	{
		printf("Unable to allocate memory for the image varable! Return.\n");
		if (tmpstack)	  {	Kill_Stack(tmpstack);	tmpstack=0;}
		if (sz) {delete sz; sz=0;}
		b_error=1;
		return b_error;
	}
	else
	{
		V3DLONG i,j,k,c;
		V3DLONG pgsz1=sz[2]*sz[1]*sz[0], pgsz2=sz[1]*sz[0], pgsz3=sz[0];

		switch (tmpstack->kind)
		{
			case GREY:
			case COLOR:
				for (c=0;c<sz[3];c++)
					for (k=0;k<sz[2]; k++)
						for (j=0;j<sz[1]; j++)
							for (i=0;i<sz[0]; i++)
								//img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = STACK_PIXEL_8(tmpstack,i,j,k,c);
								img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = Get_Stack_Pixel(tmpstack,i,j,k,c);

				break;

			case GREY16:
				for (c=0;c<sz[3];c++)
					for (k=0;k<sz[2]; k++)
						for (j=0;j<sz[1]; j++)
							for (i=0;i<sz[0]; i++)
								//img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = STACK_PIXEL_16(tmpstack,i,j,k,c)>>4; //assume it is 12-bit
								img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = Get_Stack_Pixel(tmpstack,i,j,k,c)>>4; //assume it is 12-bit
				break;

			default:
				printf("The type of tif file is not supported in this version.\n");
				if (sz) {delete sz; sz=0;}
					if (img) {delete img; img=0;}
					Kill_Stack(tmpstack); tmpstack=0;
				b_error=1;
				return b_error;
				break;
		}
	}


	// kill stack
	if (tmpstack)
	{
		Kill_Stack(tmpstack);
		tmpstack=0;
	}

	return b_error;

}


//070806 - LSM file reading

int read_lsm_slice(TIFF *in, unsigned char * pointer_first_page, V3DLONG pagepixelnumber, V3DLONG channelpixelnumber, int datatype)
{
	if (TIFFIsTiled(in))
		return (read_lsm_slice_tile(in, pointer_first_page, pagepixelnumber, channelpixelnumber, datatype));
	else
		return (read_lsm_slice_strip(in, pointer_first_page, pagepixelnumber, channelpixelnumber, datatype));
}



int read_lsm_slice_strip(TIFF *in, unsigned char * pointer_first_page, V3DLONG pagepixelnumber, V3DLONG channelpixelnumber, int datatype)
{
	tsize_t bufsize  = TIFFStripSize(in);
	if ((pagepixelnumber*datatype)!=bufsize)
	{
		fprintf(stderr, "The current strip has a different size from the expected size in read_lsm_slice_strip(). No data is read.\n");
		return 1;
	}

	//unsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize);

	/*
    uint8 * row = image->array;
	V3DLONG width  = image->width;
	V3DLONG height = image->height;
	V3DLONG totalpixel=width*height;
	*/

	//if (buf) {
	if (pointer_first_page) {
		tstrip_t s, ns = TIFFNumberOfStrips(in);
		uint32 *bytecounts;
		uint32 *stripoffsets;

		TIFFGetField(in, TIFFTAG_STRIPBYTECOUNTS, &bytecounts);

		TIFFGetField(in, TIFFTAG_STRIPOFFSETS, &stripoffsets);

		for (s = 0; s < ns; s++)
		{
			//printf("TIFFTAG_STRIPBYTECOUNTS and TIFFTAG_STRIPOFFSETS are [%d][%ld][%ld]\n", s, bytecounts[s], stripoffsets[s]);
			//if (TIFFReadEncodedStrip(in, s, pointer_first_page + V3DLONG(s)*channelpixelnumber, (tsize_t) -1)<0)

			//if (TIFFReadEncodedStrip(in, s, pointer_first_page + V3DLONG(s)*channelpixelnumber, pagepixelnumber)<0) //*datatype, 080301
			if (TIFFReadEncodedStrip(in, s, pointer_first_page + V3DLONG(s)*channelpixelnumber*datatype, pagepixelnumber*datatype)<0) //*datatype, 080301 to handle 12/16 bit LSM
			//if (phc_TIFFReadEncodedStrip(in, s, pointer_first_page + V3DLONG(s)*channelpixelnumber, pagepixelnumber)<0)
			{
//				_TIFFfree(buf);
				//return (0);
				//(*in->tif_postdecode)(in, pointer_first_page + V3DLONG(s)*channelpixelnumber, pagepixelnumber);
				continue;
			}
/*			else
			{
				unsigned char * curpt = ;
				V3DLONG i;
				for (i=0;i<bufsize;i++)
				{
					*curpt++ = (uint8)(buf[i]); //force the conversion. no work for 12-bit lsm yet. PHC 070806
				}
			}
			*/
		}
		//_TIFFfree(buf);
		return (1);
	}
	return 0;
}


int read_lsm_slice_tile(TIFF *in, unsigned char * pointer_first_page, V3DLONG pagepixelnumber, V3DLONG channelpixelnumber, int datatype)
{
	tsize_t bufsize = TIFFTileSize(in);
	if ((pagepixelnumber*datatype)!=bufsize)
	{
		fprintf(stderr, "The current tile has a different size from the expected size in read_lsm_slice_tile(). No data is read.\n");
		return 1;
	}

	//unsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize);

	//if (buf) {
	if (pointer_first_page) {
		ttile_t t, nt = TIFFNumberOfTiles(in);
		uint32 *bytecounts;

		TIFFGetField(in, TIFFTAG_TILEBYTECOUNTS, &bytecounts);
		for (t = 0; t < nt; t++)
		{
			//if (TIFFReadEncodedTile(in, t, buf, bytecounts[t]) < 0)
			if (TIFFReadEncodedTile(in, t, pointer_first_page + V3DLONG(t)*channelpixelnumber, bytecounts[t]) < 0)
			{
//				_TIFFfree(buf);
				return (0);
			}
			/*
			else
			{
				V3DLONG i;
				for (i=0;i<bufsize;i++)
				{
					row[i*3+s] = (uint8)(buf[i]); //force the conversion. no work for 12-bit lsm yet. PHC 070806
				}
			}
			*/
		}
		//_TIFFfree(buf);
		return (1);
	}
	return 0;
}

int loadLsm2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype)
{
	int berror=0;

	TIFF  *tif=0;
	int depth, width, height;
	short bits, colorchannels;

	tif = Open_Tiff(filename,"r");
	if (!tif)
	{
		fprintf(stderr, "Open_TIFF function failed.\n");
		fprintf(stderr, "Cannot open the specified LSM file in loadLsm2Stack(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	depth = 1;
	while (TIFFReadDirectory(tif))
		depth += 1;
	TIFFClose(tif);

	printf("Total # of directories is %d, half of them are thumbnails So real data have %d slices.\n", depth, depth/2);
	depth = depth / 2;		/* half the dirs are thumbnails */

	tif = Open_Tiff(filename,"r");
	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);
	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);
	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels);
	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);

	if (bits<=8 && bits>0) datatype=1;
	else if (bits<=16 && bits>0) datatype=2;
	else
	{
		fprintf(stderr, "LSM file should not support more than 16 bits data. Check the codes in loadLsm2Stack(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	V3DLONG pixel_per_slice, pixel_per_channel, ntotalpixel;
	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		fprintf(stderr,"Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	else
	{
		sz[0] = width;
		sz[1] = height;
		sz[2] = depth;
		sz[3] = colorchannels;
		pixel_per_slice = V3DLONG(width)*V3DLONG(height);
		pixel_per_channel = pixel_per_slice*V3DLONG(depth);
		ntotalpixel = pixel_per_channel*colorchannels;
	}

	if (img) {delete []img; img=0;}
	else
	{
		img = new unsigned char [V3DLONG(ntotalpixel)*V3DLONG(datatype)];
		if (!img)
		{
			fprintf(stderr,"Fail to allocate memory.\n");
			if (sz) {delete []sz;sz=0;}
			berror = 1;
			return berror;
		}
	}

	// read every other directory (real data, the in between are thumbnails
	V3DLONG d;
	short cur_colorchannels, cur_bits;
	int cur_width, cur_height;
	for (d=0;d<depth;d++)
	{
		TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);
		TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);
		TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels);
		TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);

		//printf("d=%ld, current width=%d, height=%d, cur_colorchannels=%d, cur_bits=%d\n", d, cur_width, cur_height, cur_colorchannels, cur_bits); fflush(stdout); //080301

		if (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits)
		{
			fprintf(stderr, "The %ld Individual image slice has a different size/colorchannel/bits from the first slice!", d);
			//in this case, do nothing to read the data and leave it empty
		}
		else
		{
			read_lsm_slice(tif, img+V3DLONG(d)*V3DLONG(pixel_per_slice)*V3DLONG(datatype), pixel_per_slice, pixel_per_channel, datatype);
		}

		if (d==depth-1)
			break; //no need to do read directory anymore once the last one is read
		else
		{
			if (!TIFFReadDirectory(tif)) break;	  /* skip the one we just read, it's a thumbnail  */
			if (!TIFFReadDirectory(tif)) break;	  /* get the next slice  */
		}
	}

	TIFFClose(tif);

	//return (stack);
	return berror;
}


int loadLsmThumbnail2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype)
{
	int berror=0;

	TIFF  *tif=0;
	int depth, width, height;
	short bits, colorchannels;

	tif = Open_Tiff(filename,"r");
	if (!tif)
	{
		fprintf(stderr, "Cannot open the specified LSM file in loadLsmThumbnail2Stack(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	depth = 1;
	while (TIFFReadDirectory(tif))
		depth += 1;
	TIFFClose(tif);

	printf("Total # of directories is %d, half of them are thumbnails So real data have %d slices.\n", depth, depth/2);
	depth = depth / 2;		/* half the dirs are thumbnails */

	tif = Open_Tiff(filename,"r");

	TIFFReadDirectory(tif); //get to the first thumbnail image
//
	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);
	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);
	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels);
	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);

	if (bits<=8 && bits>0) datatype=1;
	else if (bits<=16 && bits>0) datatype=2;
	else
	{
		fprintf(stderr, "LSM file should not support more than 16 bits data. Check the codes in loadLsm2Stack(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	V3DLONG pixel_per_slice, pixel_per_channel, ntotalpixel;
	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		fprintf(stderr,"Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	else
	{
		sz[0] = width;
		sz[1] = height;
		sz[2] = depth;
		sz[3] = colorchannels;
		pixel_per_slice = V3DLONG(width)*V3DLONG(height);
		pixel_per_channel = pixel_per_slice*V3DLONG(depth);
		ntotalpixel = pixel_per_channel*colorchannels;
	}

	if (img) {delete []img; img=0;}
	else
	{
		img = new unsigned char [V3DLONG(ntotalpixel)*V3DLONG(datatype)];
		if (!img)
		{
			fprintf(stderr,"Fail to allocate memory.\n");
			if (sz) {delete []sz;sz=0;}
			berror = 1;
			return berror;
		}
	}

	// read every other directory (real data, the in between are thumbnails
	V3DLONG d;
	short cur_colorchannels, cur_bits;
	int cur_width, cur_height;
	for (d=0;d<depth;d++)
	{
		TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);
		TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);
		TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels);
		TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);

		//printf("d=%ld, current width=%d, height=%d, cur_colorchannels=%d, cur_bits=%d\n", d, cur_width, cur_height, cur_colorchannels, cur_bits); fflush(stdout); //080301

		if (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits)
		{
			fprintf(stderr, "The %ld Individual image slice has a different size/colorchannel/bits from the first slice!",d);
			//in this case, do nothing to read the data and leave it empty
		}
		else
		{
			read_lsm_slice(tif, img+V3DLONG(d)*V3DLONG(pixel_per_slice)*V3DLONG(datatype), pixel_per_slice, pixel_per_channel, datatype);
		}

		if (d==depth-1)
			break; //no need to do read directory anymore once the last one is read
		else
		{
			if (!TIFFReadDirectory(tif)) break;	  /* skip the one we just read, it's a normal frame  */
			if (!TIFFReadDirectory(tif)) break;	  /* get the next thumbnail image  */
		}
	}

	TIFFClose(tif);

	return berror;
}

int loadLsmThumbnail2Stack_middle(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype)
{
	int berror=0;

	TIFF  *tif=0;
	int depth, width, height;
	short bits, colorchannels;

	tif = Open_Tiff(filename,"r");
	if (!tif)
	{
		fprintf(stderr, "Cannot open the specified LSM file in loadLsmThumbnail2Stack_middle(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	depth = 1;
	while (TIFFReadDirectory(tif))
		depth += 1;
	TIFFClose(tif);

	printf("Total # of directories is %d, half of them are thumbnails So real data have %d slices.\n", depth, depth/2);
	depth = depth / 2;		/* half the dirs are thumbnails */

	tif = Open_Tiff(filename,"r");
	TIFFReadDirectory(tif); //bypass a big image and get to the first thumbnail image

	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);
	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);
	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels);
	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);

	if (bits<=8 && bits>0) datatype=1;
	else if (bits<=16 && bits>0) datatype=2;
	else
	{
		fprintf(stderr, "LSM file should not support more than 16 bits data. Check the codes in loadLsm2Stack(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	V3DLONG pixel_per_slice, pixel_per_channel, ntotalpixel;
	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		fprintf(stderr,"Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	else
	{
		sz[0] = width;
		sz[1] = height;
		sz[2] = 1;
		sz[3] = colorchannels;
		pixel_per_slice = V3DLONG(width)*V3DLONG(height);
		pixel_per_channel = pixel_per_slice*V3DLONG(sz[2]);
		ntotalpixel = pixel_per_channel*colorchannels;
	}

	if (img) {delete []img; img=0;}
	else
	{
		img = new unsigned char [V3DLONG(ntotalpixel)*V3DLONG(datatype)];
		if (!img)
		{
			fprintf(stderr,"Fail to allocate memory.\n");
			if (sz) {delete []sz;sz=0;}
			berror = 1;
			return berror;
		}
	}

	// read every other directory (real data, the in between are thumbnails )

	V3DLONG d;
	short cur_colorchannels, cur_bits;
	int cur_width, cur_height;
	for (d=0;d<=int(depth/2);d++)
	{
		if (d<int(depth/2))
		{
			TIFFReadDirectory(tif); //bypass a thumbnail
			TIFFReadDirectory(tif); //bypass a big image
			continue;
		}

		TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);
		TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);
		TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels);
		TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);

		printf("d=%ld, current width=%d, height=%d\n", d, cur_width, cur_height); fflush(stdout);

		if (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits)
		{
			fprintf(stderr, "The %ld Individual image slice has a different size/colorchannel/bits from the first slice!", d);
			//in this case, do nothing to read the data and leave it empty
		}
		else
		{
		    //note that as we onlky read one slice here, the "img+V3DLONG(d)*V3DLONG(pixel_per_slice)*V3DLONG(datatype)" equals "img"
			read_lsm_slice(tif, img, pixel_per_slice, pixel_per_channel, datatype);
		}

		break; //after we read one slice, then stop;
	}

	TIFFClose(tif);

	return berror;
}

int loadLsm2Stack_middle(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype)
{
	int berror=0;

	TIFF  *tif=0;
	int depth, width, height;
	short bits, colorchannels;

	tif = Open_Tiff(filename,"r");
	if (!tif)
	{
		fprintf(stderr, "Cannot open the specified LSM file in loadLsm2Stack_middle(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	depth = 1;
	while (TIFFReadDirectory(tif))
		depth += 1;
	TIFFClose(tif);

	printf("Total # of directories is %d, half of them are thumbnails So real data have %d slices.\n", depth, depth/2);
	depth = depth / 2;		/* half the dirs are thumbnails */

	tif = Open_Tiff(filename,"r");

	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);
	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);
	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels);
	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);

	if (bits<=8 && bits>0) datatype=1;
	else if (bits<=16 && bits>0) datatype=2;
	else
	{
		fprintf(stderr, "LSM file should not support more than 16 bits data. Check the codes in loadLsm2Stack(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	V3DLONG pixel_per_slice, pixel_per_channel, ntotalpixel;
	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		fprintf(stderr,"Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	else
	{
		sz[0] = width;
		sz[1] = height;
		sz[2] = 1;
		sz[3] = colorchannels;
		pixel_per_slice = V3DLONG(width)*V3DLONG(height);
		pixel_per_channel = pixel_per_slice*V3DLONG(sz[2]);
		ntotalpixel = pixel_per_channel*colorchannels;
	}

	if (img) {delete []img; img=0;}
	else
	{
		img = new unsigned char [V3DLONG(ntotalpixel)*V3DLONG(datatype)];
		if (!img)
		{
			fprintf(stderr,"Fail to allocate memory.\n");
			if (sz) {delete []sz;sz=0;}
			berror = 1;
			return berror;
		}
	}

	// read every other directory (real data, the in between are thumbnails )

	V3DLONG d;
	short cur_colorchannels, cur_bits;
	int cur_width, cur_height;
	for (d=0;d<=int(depth/2);d++)
	{
		if (d<int(depth/2))
		{
			TIFFReadDirectory(tif); //bypass a big image
			TIFFReadDirectory(tif); //bypass a thumbnail
			continue;
		}

		TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);
		TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);
		TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels);
		TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);

		printf("d=%ld, current width=%d, height=%d\n", d, cur_width, cur_height); fflush(stdout);

		if (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits)
		{
			fprintf(stderr, "The %ld Individual image slice has a different size/colorchannel/bits from the first slice!", d);
			//in this case, do nothing to read the data and leave it empty
		}
		else
		{
		    //note that as we onlky read one slice here, the "img+V3DLONG(d)*V3DLONG(pixel_per_slice)*V3DLONG(datatype)" equals "img"
			read_lsm_slice(tif, img, pixel_per_slice, pixel_per_channel, datatype);
		}

		break; //after we read one slice, then stop;
	}

	TIFFClose(tif);

	return berror;
}


int loadLsmSlice(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, V3DLONG sliceno, bool b_thumbnail)
{
	int berror=0;

	if (sliceno<-2)
	{
		fprintf(stderr, "The sliceno parameter is invalid. Must not <-2: -2 to read all slices, -1 to read middle only, 0 to N-1 to read the 1 to N-1 slice. If bigger than N-1, then just read the last slice.\n");
		return 1; //070805, by Hanchuan Peng
	}

	TIFF  *tif=0;
	int depth, width, height;
	short bits, colorchannels;

	tif = Open_Tiff(filename,"r");
	if (!tif)
	{
		fprintf(stderr, "Cannot open the specified LSM file in loadLsmSlice(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	depth = 1;
	while (TIFFReadDirectory(tif))
		depth += 1;
	TIFFClose(tif);

	printf("%d\n", depth/2);
	//printf("Total # of directories is %d, half of them are thumbnails So real data have %d slices.\n", depth, depth/2);
	depth = depth / 2;		/* half the dirs are thumbnails */
	if (sliceno>depth-1) sliceno=depth-1;
	//printf("slice #=%d\n", sliceno);

	tif = Open_Tiff(filename,"r");

	if (b_thumbnail)
		TIFFReadDirectory(tif); //by pass one big image and get to the first thumbnail image

	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);
	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);
	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels);
	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);

	if (bits<=8 && bits>0) datatype=1;
	else if (bits<=16 && bits>0) datatype=2;
	else
	{
		fprintf(stderr, "LSM file should not support more than 16 bits data. Check the codes in loadLsm2Slice(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	V3DLONG pixel_per_slice, pixel_per_channel, ntotalpixel;
	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		fprintf(stderr,"Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	else
	{
		sz[0] = width;
		sz[1] = height;
		sz[2] = (sliceno==-2) ? depth : 1;
		sz[3] = colorchannels;
		pixel_per_slice = V3DLONG(sz[1])*V3DLONG(sz[0]);
		pixel_per_channel = pixel_per_slice*V3DLONG(sz[2]);
		ntotalpixel = pixel_per_channel*colorchannels;
	}

	if (img) {delete []img; img=0;}
	else
	{
		img = new unsigned char [V3DLONG(ntotalpixel)*V3DLONG(datatype)];
		if (!img)
		{
			fprintf(stderr,"Fail to allocate memory.\n");
			if (sz) {delete []sz;sz=0;}
			berror = 1;
			return berror;
		}
	}

	// read every other directory (real data, the in between are thumbnails
    bool b_readnow=false;
	V3DLONG d;
	short cur_colorchannels, cur_bits;
	int cur_width, cur_height;
	for (d=0;d<depth;d++)
	{
		if (sliceno>-2)
		{
			if (sliceno==-1) //middle slice only
			{
				b_readnow=(d==int(depth/2))?true:false;
			}
			else
			{
				b_readnow=(d==sliceno)?true:false;
			}
		}
		else
		{
			b_readnow=true;
		}

		if (b_readnow)
		{
			TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);
			TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);
			TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels);
			TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);

			//printf("d=%d, current width=%d, height=%d, cur_colorchannels=%d, cur_bits=%d\n", d, cur_width, cur_height, cur_colorchannels, cur_bits); fflush(stdout); //080301

			if (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits)
			{
				fprintf(stderr, "The %ld Individual image slice has a different size/colorchannel/bits from the first slice!", d);
				//in this case, do nothing to read the data and leave it empty
			}
			else
			{
				if (sliceno==-2)
				{
					read_lsm_slice(tif, img+V3DLONG(d)*V3DLONG(pixel_per_slice)*V3DLONG(datatype), pixel_per_slice, pixel_per_channel, datatype);
				}
				else
				{
					read_lsm_slice(tif, img, pixel_per_slice, pixel_per_channel, datatype);
					break; //because only 1 read is needed in this case
				}
			}
		}

		if (d==depth-1)
			break; //no need to do read directory anymore once the last one is read
		else
		{
			if (!TIFFReadDirectory(tif)) break;	  /* one directory  */
			if (!TIFFReadDirectory(tif)) break;	  /* another directory */
		}
	}

	TIFFClose(tif);

	return berror;
}

//The following 3 functions are added on 2008-02-13
int loadTifSlice(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, V3DLONG sliceno, bool b_thumbnail)
{
	int berror=0;

	if (sliceno<-2)
	{
		fprintf(stderr, "The sliceno parameter is invalid. Must not <-2: -2 to read all slices, -1 to read middle only, 0 to N-1 to read the 1 to N-1 slice. If bigger than N-1, then just read the last slice.\n");
		return 1;
	}

	TIFF  *tif=0;
	int depth, width, height;
	short bits, colorchannels;

	tif = Open_Tiff(filename,"r");
	if (!tif)
	{
		fprintf(stderr, "Cannot open the specified TIFF file in loadTifSlice(). \n");
		return 1;
	}

	depth = 1;
	while (TIFFReadDirectory(tif))
		depth += 1;
	TIFFClose(tif);

	printf("%d\n", depth); //note that this sentence will be output an important info to use the pop_thumbnail php program
	//printf("Total # of directories is %d, half of them are thumbnails So real data have %d slices.\n", depth, depth/2);
	//depth = depth / 2;		/* half the dirs are thumbnails */
	if (sliceno>depth-1) sliceno=depth-1;
	//printf("slice #=%d\n", sliceno);

	tif = Open_Tiff(filename,"r");

	//if (b_thumbnail) TIFFReadDirectory(tif); //by pass one big image and get to the first thumbnail image

	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);
	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);
	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels);
	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);

	if (bits<=8 && bits>0) datatype=1;
	else if (bits<=16 && bits>0) datatype=2;
	else
	{
		fprintf(stderr, "TIF file should not support more than 16 bits data. Check the codes in loadTifSlice(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	V3DLONG pixel_per_slice, pixel_per_channel, ntotalpixel;
	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		fprintf(stderr,"Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	else
	{
		sz[0] = width;
		sz[1] = height;
		sz[2] = (sliceno==-2) ? depth : 1;
		sz[3] = colorchannels;
		pixel_per_slice = V3DLONG(sz[1])*V3DLONG(sz[0]);
		pixel_per_channel = pixel_per_slice*V3DLONG(sz[2]);
		ntotalpixel = pixel_per_channel*colorchannels;
	}

	if (img) {delete []img; img=0;}
	else
	{
		img = new unsigned char [V3DLONG(ntotalpixel)*V3DLONG(datatype)];
		if (!img)
		{
			fprintf(stderr,"Fail to allocate memory.\n");
			if (sz) {delete []sz;sz=0;}
			berror = 1;
			return berror;
		}
	}

	// read every other directory (real data, the in between are thumbnails
    bool b_readnow=false;
	V3DLONG d;
	short cur_colorchannels, cur_bits;
	int cur_width, cur_height;
	for (d=0;d<depth;d++)
	{
		if (sliceno>-2)
		{
			if (sliceno==-1) //middle slice only
			{
				b_readnow=(d==int(depth/2))?true:false;
			}
			else
			{
				b_readnow=(d==sliceno)?true:false;
			}
		}
		else
		{
			b_readnow=true;
		}

		if (b_readnow)
		{
			TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);
			TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);
			TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels);
			TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);

			//printf("d=%d, current width=%d, height=%d\n", d, cur_width, cur_height); fflush(stdout);

			if (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits)
			{
				fprintf(stderr, "The %ld Individual image slice has a different size/colorchannel/bits from the first slice!", d);
				//in this case, do nothing to read the data and leave it empty
			}
			else
			{
				if (sliceno==-2)
				{
					read_tif_slice(tif, img+V3DLONG(d)*V3DLONG(pixel_per_slice)*V3DLONG(datatype)*sz[3], width, height);
					//printf("Read No. %d slice.\n", d);
				}
				else
				{
					read_tif_slice(tif, img, width, height);
					//printf("width=[%d] height=[%d] color=[%d] bits-per-sample=[%d].\n", width, height, cur_colorchannels, cur_bits);
					//printf("Read No. %d slice.\n", d);
					//read_directory(tif,Select_Plane(stack,d),"Read_Stack");
					break; //because only 1 read is needed in this case
				}
			}
		}

		if (d==depth-1)
			break; //no need to do read directory anymore once the last one is read
		else
		{
			if (!TIFFReadDirectory(tif)) break;	  /* one directory  */
			//if (!TIFFReadDirectory(tif)) break;	  /* another directory */
		}
	}

	TIFFClose(tif);

	//debugging code: verification succeeds in Matlab reading code:
	//t=fopen('/Users/pengh/Desktop/temp/test1.dat');a=fread(t, 512*512*3, 'uint8');a=reshape(a,[3 512 512]);a=permute(a, [2 3 1]);fclose(t); imshow(a(:,:,1:3)/255)

	//FILE * tmp_fp=fopen("/Users/pengh/temp/test1.dat", "w");
	//fwrite(img, 3, width*height,tmp_fp);
	//fclose(tmp_fp);


	//produce thumbnail if required
	if (b_thumbnail)
	{
		V3DLONG thumbsz0=128, thumbsz1=128;
		if (sz[0]>thumbsz0 || sz[1]>thumbsz1)
		{
			unsigned char * img1 = new unsigned char [V3DLONG(thumbsz0)*thumbsz1*sz[2]*sz[3]*V3DLONG(datatype)];
			unsigned char ****img4d1 = 0;
			new4dpointer(img4d1, sz[3], thumbsz0, thumbsz1, sz[2], img1);

			unsigned char ****img4d = 0;
			new4dpointer(img4d, sz[3], sz[0], sz[1], sz[2], img);

			double factor_jj=sz[1]/thumbsz1, factor_ii=sz[0]/thumbsz0;
			for (V3DLONG kk=0;kk<sz[2];kk++)
			{
				for (V3DLONG jj=0; jj<thumbsz1; jj++)
				{
					for (V3DLONG ii=0;ii<thumbsz0; ii++)
					{
						for (V3DLONG cc=0;cc<sz[3];cc++)
						{
							img4d1[kk][jj][ii][cc] = img4d[kk][V3DLONG(floor(jj*factor_jj))][V3DLONG(floor(ii*factor_ii))][cc];
						}
					}
				}
			}

			delete4dpointer(img4d, sz[3], sz[0], sz[1], sz[2]);
			delete4dpointer(img4d1, sz[3], thumbsz0, thumbsz1, sz[2]);

			delete []img;
			img = img1;
			sz[0] = thumbsz0;
			sz[1] = thumbsz1;
			//sz[2] and sz[3] do not need change
		}
	}

	//FILE * tmp_fp=fopen("/Users/pengh/temp/test1.dat", "w");
	//fwrite(img, 3, width*height,tmp_fp);
	//fclose(tmp_fp);

	//permute the data to make sure it will be output correctly
	unsigned char ****img4d = 0;
	new4dpointer(img4d, sz[3], sz[0], sz[1], sz[2], img); //must realize this order!

	unsigned char * img1 = new unsigned char [sz[0]*sz[1]*sz[2]*sz[3]];
	unsigned char ****img4d1 = 0;
	new4dpointer(img4d1, sz[0], sz[1], sz[2], sz[3], img1);

	for (V3DLONG tcc=0;tcc<sz[3];tcc++)
	{
		for (V3DLONG tkk=0;tkk<sz[2];tkk++)
		{
			for (V3DLONG tjj=0;tjj<sz[1];tjj++)
			{
				for (V3DLONG tii=0;tii<sz[0];tii++)
				{
					img4d1[tcc][tkk][tjj][tii] = img4d[tkk][tjj][tii][tcc];
				}
			}
		}
	}

	delete4dpointer(img4d1, sz[0], sz[1], sz[2], sz[3]);
	delete4dpointer(img4d, sz[3], sz[0], sz[1], sz[2]);
	if (img) {delete []img; img=0;}
	img = img1;

	return berror;
}

int read_tif_slice(TIFF *tif, unsigned char * pointer_first_page, V3DLONG width, V3DLONG height)
//note that this is not a general tif slice reader, - but should work for date generated using Gene's code
{
	//	if (TIFFIsTiled(in))
	//		return (read_tif_slice_tile(in, pointer_first_page, pagepixelnumber, channelpixelnumber, datatype));
	//	else
	//		return (read_tif_slice_strip(in, pointer_first_page, pagepixelnumber, channelpixelnumber, datatype));

	//

	//first determine the image type

	enum PImagePixelType {PTIF_GREY, PTIF_GREY16, PTIF_COLOR};
	PImagePixelType pixelType;


	short bits, channels, photo;

	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);
	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &channels);
	TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photo);
	if (photo <= 1)
    {
		if (channels > 1)
			fprintf(stderr, "Black and white tiff has more than 1 channel!");
		if (bits == 16)
			pixelType = PTIF_GREY16;
		else
			pixelType = PTIF_GREY;
    }
	else
		pixelType = PTIF_COLOR;

	// then read data

	uint32 *raster = new uint32 [width*height];
	if (!raster)
	{
		fprintf(stderr, "Fail to allocate memory in read_tif_slice();\n");
		return 1;
	}

	unsigned char  *row;

	row = pointer_first_page;

	if (pixelType != PTIF_GREY16)
    {
		int i, j;
		uint32 *in;
		uint8  *out;

		if (TIFFReadRGBAImage(tif,width,height,raster,0) == 0)
		{
			fprintf(stderr, "read of tif failed in read_tif_slice()");
			if (raster) {delete []raster; raster=0;}
			return 1;
		}

		//debugging code: verification succeeds in Matlab reading code:
		//t=fopen('/Users/pengh/Desktop/temp/test1.dat');a=fread(t, 512*512*4, 'uint8');a=reshape(a,[4 512 512]);a=permute(a, [2 3 1]);fclose(t); imshow(a(:,:,1:3)/255)

		//FILE * tmp_fp=fopen("/Users/pengh/temp/test1.dat", "w");
		//fwrite(raster, 4, width*height,tmp_fp);
		//fclose(tmp_fp);

		in = raster;
		if (pixelType == PTIF_GREY)
        {
			for (j = height-1; j >= 0; j--)
			{
				out = row;
				for (i = 0; i < width; i++)
				{
					uint32 pixel = *in++;
					*out++ = TIFFGetR(pixel);
				}
				row += width;
			}
        }
		else
        {
			for (j = height-1; j >= 0; j--)
			{
				out = row;
				for (i = 0; i < width; i++)
				{
					uint32 pixel = *in++;
					*out++ = TIFFGetR(pixel);
					*out++ = TIFFGetG(pixel);
					*out++ = TIFFGetB(pixel);
				}
				row += width*3;
			}
        }
    }

	else

    {
		int tile_width, tile_height;

		if (TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width))    // File is tiled
        { 
			int x, y;
			int i, j;
			int m, n;
			uint16 *buffer = (uint16 *) raster;
			uint16 *out, *in; //, *rous;

			TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height);

			for (y = 0; y < height; y += tile_height)
            { 
				if (y + tile_height > height)
                n = height - y;
				else
					n = tile_height;
				for (x = 0; x < width; x += tile_width)
                { 
					TIFFReadTile(tif, buffer, x, y, 0, 0);
					if (x + tile_width > width)
						m = width - x;
					else
						m = tile_width;
					for (j = 0; j < n; j++)
                    { out = (uint16 *) (row + 2*(j*width + x));
						in  = buffer + j*tile_width;
						for (i = 0; i < m; i++)
							*out++ = *in++;
                    }
                }
				row += n*width*2;
            }
        }

		else    // File is striped

        { int     y;

			for (y = 0; y < height; y++)
            {
				TIFFReadScanline(tif, row, y, 0);
				row += width*2;
            }
        }
    }

	if (raster) {delete []raster; raster=0;}
	//
	return 0;
	//

}
int read_tif_slice_strip(TIFF *in, unsigned char * pointer_first_page, V3DLONG pagepixelnumber, V3DLONG channelpixelnumber, int datatype)
{
	tsize_t bufsize  = TIFFStripSize(in);
	if (pagepixelnumber!=bufsize)
	{
		fprintf(stderr, "The current strip has a different size [%ld] from the expected size [%ld] in read_tif_slice_strip(). No data is read.\n", V3DLONG(bufsize), pagepixelnumber);
		return 1;
	}

	if (pointer_first_page) {
		tstrip_t s, ns = TIFFNumberOfStrips(in);
		uint32 *bytecounts;
		uint32 *stripoffsets;

		TIFFGetField(in, TIFFTAG_STRIPBYTECOUNTS, &bytecounts);

		TIFFGetField(in, TIFFTAG_STRIPOFFSETS, &stripoffsets);

		for (s = 0; s < ns; s++)
		{
			if (TIFFReadEncodedStrip(in, s, pointer_first_page + V3DLONG(s)*channelpixelnumber, pagepixelnumber)<0)
			{
				continue;
			}
		}
		return (1);
	}
	return 0;
}


int read_tif_slice_tile(TIFF *in, unsigned char * pointer_first_page, V3DLONG pagepixelnumber, V3DLONG channelpixelnumber, int datatype)
{
	tsize_t bufsize = TIFFTileSize(in);
	if (pagepixelnumber!=bufsize)
	{
		fprintf(stderr, "The current tile has a different size from the expected size in read_tif_slice_tile(). No data is read.\n");
		return 1;
	}

	if (pointer_first_page) {
		ttile_t t, nt = TIFFNumberOfTiles(in);
		uint32 *bytecounts;

		TIFFGetField(in, TIFFTAG_TILEBYTECOUNTS, &bytecounts);
		for (t = 0; t < nt; t++)
		{
			if (TIFFReadEncodedTile(in, t, pointer_first_page + V3DLONG(t)*channelpixelnumber, bytecounts[t]) < 0)
			{
				return (0);
			}
		}
		return (1);
	}
	return 0;
}


int loadRawSlice(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, V3DLONG sliceno, bool b_thumbnail) //reserved for future use
{
return 0;
}

int loadRawSlice_2byte(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, V3DLONG sliceno, bool b_thumbnail) //reserved for future use
{
return 0;
}


int loadMRC2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype) // MRC reading
{
	int berror = 0;

	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);

	//read header
	BIT32_UNIT mysz[4];
	mysz[0]=mysz[1]=mysz[2]=mysz[3]=0;
	int tmpn=fread(mysz, 4, 3, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (tmpn!=3)
	{
		printf("This program only reads [%d] units.\n", tmpn);
		berror=1;
		return berror;
	}
	mysz[3]=1; //now set #ch = 1

	V3DLONG dcode = 0;
	fread(&dcode, 4, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */

	switch (dcode)
	{
		case 0: //signed 8bit
			datatype = 1;
			break;

		case 1: //signed 16bit
		case 6: //unsigned 16-bit
			datatype = 2;
			break;

		case 2: //float
			datatype = 4;
			break;

		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			berror = 1;
			return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	fseek(fid,1024,SEEK_SET);

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1;
	V3DLONG i, nread;
	for (i=0;i<4;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		totalUnit *= sz[i];
	}

	if ((totalUnit*unitSize+1024) != fileSize)
	{
		printf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+1024);
		printf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
		if (b_VERBOSE_PRINT)
		{
			printf("The read sizes are: %d %d %d %d\n", mysz[0], mysz[1], mysz[2], mysz[3]);
		}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (img) {delete []img; img=0;}
	img = new unsigned char [totalUnit*unitSize];
	if (!img)
	{
		printf("Fail to allocate memory.\n");
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	nread = fread(img, unitSize, totalUnit, fid);
	if (nread!=totalUnit)
	{
		printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, totalUnit);
		if (sz) {delete []sz; sz=0;}
		if (img) {delete []img; img=0;}
		berror = 1;
		return berror;
	}

//	/* swap the data bytes if necessary */
//
//	if (b_swap==1)
//	{
//		if (unitSize==2)
//		{
//			for (i=0;i<totalUnit; i++)
//			{
//				swap2bytes((void *)(img+i*unitSize));
//			}
//		}
//		else if (unitSize==4)
//		{
//			for (i=0;i<totalUnit; i++)
//			{
//				swap4bytes((void *)(img+i*unitSize));
//			}
//		}
//	}

	/* clean and return */

	fclose(fid);

	return berror;
}

int saveStack2MRC(const char * filename, const unsigned char * img, const V3DLONG * sz, int datatype) // MRC writing
{
	int berror=0;
	return berror;
}


//070214: add a simple interface to read and save all supported file formats

bool ensure_file_exists_and_size_not_too_big(char *filename, V3DLONG sz_thres)
{
	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("The file [%s] does not exist or cannot be read.\n", filename);
		return false;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);
	fclose(fid);

	if(fileSize>sz_thres)
	{
		printf("The file [%s] has a too big size [= %ld bytes ] > [%ld bytes] which is the limit of the loadImage function. Do nothing. \n", filename, fileSize, sz_thres);
		return false;
	}

	return true;
}

//

bool loadImage(char imgSrcFile[], unsigned char *& data1d, V3DLONG * &sz, int & datatype)
{
	if (data1d)
	{
		printf("Warning: The pointer for 1d data storage is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []data1d; data1d=0;
	}
	if (sz)
	{
		printf("Warning: The pointer for size is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []sz; sz=0;
	}
	else
	{
		sz = new V3DLONG [4];
		if (!sz)
		{
			printf("Fail to alocate memory for the size variable.\n");
			return false;
		}
	}

	unsigned char *tmp_data1d =0;
	V3DLONG * tmp_sz = 0; /* note that this variable must be initialized as NULL. */
	int tmp_datatype = 0;
	bool b_5d=false;

	char * curFileSuffix = getSurfix(imgSrcFile);
	if (b_VERBOSE_PRINT)
		printf("The current input file has the surfix [%s]\n", curFileSuffix);
	if (strcasecmp(curFileSuffix, "tif")==0 || strcasecmp(curFileSuffix, "tiff")==0) //read tiff stacks
	{
		if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*900)) //tif file at most should be 900M bytes
		{
			printf("The tif file may not exist or may be too big to load.\n");
			return false;
		}
		if (loadTif2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
		{
			printf("Error happens in TIF file reading. Stop. \n");
			return false;
		}
	}
	else if ( strcasecmp(curFileSuffix, "lsm")==0 ) //read lsm stacks
	{
		if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*900)) //lsm file at most should be 900M bytes
		{
			printf("The lsm file may not exist or may be too big to load.\n");
			return false;
		}
		if (loadLsm2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
		{
			printf("Error happens in LSM file reading. Stop. \n");
			return false;
		}
	}
	else if ( strcasecmp(curFileSuffix, "raw5")==0 ) //read lsm stacks
	{
		if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //
		{
			printf("The lsm file may not exist or may be too big to load.\n");
			return false;
		}
		if (loadRaw5d2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
		{
			printf("Error happens in V3D .raw5 (5D) file reading. Stop. \n");
			return false;
		}
		b_5d = true;
	}
	else //then assume it is Hanchuan's RAW format
	{
		if (b_VERBOSE_PRINT)
			printf("The data is not with a TIF/LSM surfix, -- now this program assumes it is RAW format defined by Hanchuan Peng. \n");
		if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //RAW file at most should be 1.5G bytes
		{
			printf("The RAW file may not exist or may be too big to load.\n");
			return false;
		}

		if (loadRaw2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
		{
			if (b_VERBOSE_PRINT)
				printf("The data doesn't look like a correct 4-byte-size RAW file. Try 2-byte-raw. \n");
			if (loadRaw2Stack_2byte(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
			{
				printf("Error happens in reading 2-byte-size RAW file. Stop. \n");
				return false;
			}
		}
	}


	//copy output data

	switch (tmp_datatype)
	{
		case 1:
			datatype = 1;
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Something wrong with the program, -- should NOT display this message at all. Check your program. \n");
			if (data1d) {delete []data1d; data1d=0;}
				if (tmp_sz) {delete []tmp_sz; tmp_sz=0;}
				if (sz) {delete []sz; sz=0;}
				return false;
	}

	sz = new V3DLONG [5];
	sz[0] = tmp_sz[0];
	sz[1] = tmp_sz[1];
	sz[2] = tmp_sz[2];
	sz[3] = tmp_sz[3]; //no longer merge the 3rd and 4th dimensions
	sz[4] = (b_5d) ? tmp_sz[4] : 1; //090802

	data1d = tmp_data1d;

	/* clean all workspace variables */

	if (tmp_sz) {delete []tmp_sz; tmp_sz=0;}

	return true;
}

bool loadImage(char imgSrcFile[], unsigned char *& data1d, V3DLONG * &sz, V3DLONG * &szo, V3DLONG startx,V3DLONG starty,V3DLONG startz, 
			   V3DLONG endx,V3DLONG endy,V3DLONG endz,int & datatype)
{
	if (data1d)
	{
		printf("Warning: The pointer for 1d data storage is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []data1d; data1d=0;
	}
	if (sz)
	{
		printf("Warning: The pointer for size is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []sz; sz=0;
	}
	else
	{
		sz = new V3DLONG [4];
		if (!sz)
		{
			printf("Fail to alocate memory for the size variable.\n");
			return false;
		}
	}
	
	if (szo)
	{
		printf("Warning: The pointer for size is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []szo; szo=0;
	}
	else
	{
		szo = new V3DLONG [4];
		if (!szo)
		{
			printf("Fail to alocate memory for the size variable.\n");
			return false;
		}
	}
	
	unsigned char *tmp_data1d =0;
	V3DLONG * tmp_sz = 0; /* note that this variable must be initialized as NULL. */
	int tmp_datatype = 0;
	bool b_5d=false;
	
	char * curFileSuffix = getSurfix(imgSrcFile);
	if (b_VERBOSE_PRINT)
		printf("The current input file has the surfix [%s]\n", curFileSuffix);
	if (strcasecmp(curFileSuffix, "tif")==0 || strcasecmp(curFileSuffix, "tiff")==0) //read tiff stacks
	{
//		if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*900)) //tif file at most should be 900M bytes
//		{
//			printf("The tif file may not exist or may be too big to load.\n");
//			return false;
//		}
		if (loadTif2Stack(imgSrcFile, tmp_data1d, tmp_sz, startx,starty,startz,endx,endy,endz,tmp_datatype))
		{
			printf("Error happens in TIF file reading. Stop. \n");
			return false;
		}
			
	}
	else //then assume it is Hanchuan's RAW format
	{
		if (b_VERBOSE_PRINT)
			printf("The data is not with a TIF/LSM surfix, -- now this program assumes it is RAW format defined by Hanchuan Peng. \n");
//		if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //RAW file at most should be 1.5G bytes
//		{
//			printf("The RAW file may not exist or may be too big to load.\n");
//			return false;
//		}
		
		if (loadRaw2Stack(imgSrcFile, tmp_data1d, tmp_sz, startx,starty,startz,endx,endy,endz,tmp_datatype))
		{
			if (b_VERBOSE_PRINT)
				printf("The data doesn't look like a correct 4-byte-size RAW file. Try 2-byte-raw. \n");
			if (loadRaw2Stack_2byte(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
			{
				printf("Error happens in reading 2-byte-size RAW file. Stop. \n");
				return false;
			}
		}
	}
	
	
	//copy output data
	
	switch (tmp_datatype)
	{
		case 1:
			datatype = 1;
			break;
			
		case 2:
			datatype = 2;
			break;
			
		case 4:
			datatype = 4;
			break;
			
		default:
			printf("Something wrong with the program, -- should NOT display this message at all. Check your program. \n");
			if (data1d) {delete []data1d; data1d=0;}
			if (tmp_sz) {delete []tmp_sz; tmp_sz=0;}
			if (sz) {delete []sz; sz=0;}
			if (szo) {delete []szo; szo=0;}
			return false;
	}
	
	szo = new V3DLONG [5];
	szo[0] = endx-startx;
	szo[1] = endy-starty;
	szo[2] = endz-startz;
	szo[3] = tmp_sz[3]; //no longer merge the 3rd and 4th dimensions
	szo[4] = (b_5d) ? tmp_sz[4] : 1; 
	
	sz = new V3DLONG [5];
	sz[0] = tmp_sz[0];
	sz[1] = tmp_sz[1];
	sz[2] = tmp_sz[2];
	sz[3] = tmp_sz[3]; //no longer merge the 3rd and 4th dimensions
	sz[4] = (b_5d) ? tmp_sz[4] : 1; 
	
	printf("x=%ld y=%ld z=%ld\n",sz[0],sz[1],sz[2]);
	
    printf("xo=%ld yo=%ld zo=%ld\n",szo[0],szo[1],szo[2]);
	/* clean all workspace variables */
	data1d = tmp_data1d;
	if (tmp_sz) {delete []tmp_sz; tmp_sz=0;}
	
	return true;
}

bool loadImage(char imgSrcFile[], unsigned char *& data1d, V3DLONG * &sz, int & datatype, int chan_id_to_load) //081204
{
	//printf("*** Warning: The overloaded function loadImage() with a specified channel only works for 4-byte RAW at this moment (as of 081204) ***. \n");
	if (chan_id_to_load<0)
	{
		printf("Warning: The specified chan_id_to_load is <0. \n");
		return false;
	}

	if (data1d)
	{
		printf("Warning: The pointer for 1d data storage is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []data1d; data1d=0;
	}
	if (sz)
	{
		printf("Warning: The pointer for size is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []sz; sz=0;
	}
	else
	{
		sz = new V3DLONG [4];
		if (!sz)
		{
			printf("Fail to alocate memory for the size variable.\n");
			return false;
		}
	}

	unsigned char *tmp_data1d =0;
	V3DLONG * tmp_sz = 0; /* note that this variable must be initialized as NULL. */
	int tmp_datatype = 0;

	char * curFileSuffix = getSurfix(imgSrcFile);
	if (b_VERBOSE_PRINT)
		printf("The current input file has the surfix [%s]\n", curFileSuffix);
	if (strcasecmp(curFileSuffix, "tif")==0 || strcasecmp(curFileSuffix, "tiff")==0) //read tiff stacks
	{
		if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*900)) //tif file at most should be 900M bytes
		{
			printf("The tif file may not exist or may be too big to load.\n");
			return false;
		}
		if (loadTif2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype, chan_id_to_load))
		{
			printf("Error happens in TIF file reading. Stop. \n");
			return false;
		}
	}
	else if ( strcasecmp(curFileSuffix, "lsm")==0 ) //read lsm stacks
	{
		if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*900)) //lsm file at most should be 900M bytes
		{
			printf("The lsm file may not exist or may be too big to load.\n");
			return false;
		}
		if (loadLsm2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype, chan_id_to_load))
		{
			printf("Error happens in LSM file reading. Stop. \n");
			return false;
		}
	}
	else if ( strcasecmp(curFileSuffix, "mrc")==0 ) //read MRC stacks
	{
		if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //MRC file at most should be 1.5G bytes
		{
			printf("The MRC file may not exist or may be too big to load.\n");
			return false;
		}

		if (loadMRC2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
		{
			if (b_VERBOSE_PRINT)
				printf("The data doesn't look like a correct MRC file. \n");
			return false;
		}
	}
	else //then assume it is Hanchuan's RAW format
	{
		if (b_VERBOSE_PRINT)
			printf("The data is not with a TIF/LSM surfix, -- now this program assumes it is RAW format defined by Hanchuan Peng. \n");
		if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //RAW file at most should be 1.5G bytes
		{
			printf("The RAW file may not exist or may be too big to load.\n");
			return false;
		}

		if (loadRaw2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype, chan_id_to_load))
		{
			if (b_VERBOSE_PRINT)
				printf("The data doesn't look like a correct 4-byte-size RAW file. Try 2-byte-raw. \n");
			if (loadRaw2Stack_2byte(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype, chan_id_to_load))
			{
				printf("Error happens in reading 2-byte-size RAW file. Stop. \n");
				return false;
			}
		}
	}


	//copy output data

	switch (tmp_datatype)
	{
		case 1:
			datatype = 1;
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Something wrong with the program, -- should NOT display this message at all. Check your program. \n");
			if (data1d) {delete []data1d; data1d=0;}
				if (tmp_sz) {delete []tmp_sz; tmp_sz=0;}
				if (sz) {delete []sz; sz=0;}
				return false;
	}

	sz = new V3DLONG [5];
	sz[0] = tmp_sz[0];
	sz[1] = tmp_sz[1];
	sz[2] = tmp_sz[2];
	sz[3] = tmp_sz[3]; //no longer merge the 3rd and 4th dimensions
	sz[4] = 1; //just set the 5th dim as 1 for consistency of the other loadImage() function

	data1d = tmp_data1d;

	/* clean all workspace variables */

	if (tmp_sz) {delete []tmp_sz; tmp_sz=0;}

	return true;
}
bool loadImage_resampling(char imgSrcFile[], unsigned char *& data1d, V3DLONG * &sz, V3DLONG *&szo, int & datatype,int resampling_size) //
{
	if (data1d)
	{
		printf("Warning: The pointer for 1d data storage is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []data1d; data1d=0;
	}
	if (sz)
	{
		printf("Warning: The pointer for size is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []sz; sz=0;
	}
	else
	{
		sz = new V3DLONG [4];
		if (!sz)
		{
			printf("Fail to alocate memory for the size variable.\n");
			return false;
		}
	}
	
	if(szo)
	{
		printf("Warning: The pointer for size is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []szo; szo=0;
	}
	else
	{
		szo = new V3DLONG [4];
		if (!szo)
		{
			printf("Fail to alocate memory for the size variable.\n");
			return false;
		}
	}
	
	unsigned char *tmp_data1d =0;
	V3DLONG * tmp_sz = 0; /* note that this variable must be initialized as NULL. */
	int tmp_datatype = 0;
	bool b_5d=false;
	
	char * curFileSuffix = getSurfix(imgSrcFile);
	if (b_VERBOSE_PRINT)
		printf("The current input file has the surfix [%s]\n", curFileSuffix);
	if ( strcasecmp(curFileSuffix, "raw")==0 ) //then assume it is Hanchuan's RAW format
	{
		if (b_VERBOSE_PRINT)
			printf("The data is not with a TIF/LSM surfix, -- now this program assumes it is RAW format defined by Hanchuan Peng. \n");
			if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //RAW file at most should be 1.5G bytes
			{
				printf("The RAW file may not exist or may be too big to load.\n");
				return false;
			}
		
		if (loadRaw2Stack_resamping(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype,resampling_size))
		{
			if (b_VERBOSE_PRINT)
				printf("The data doesn't look like a correct 4-byte-size RAW file. Try 2-byte-raw. \n");
				if (loadRaw2Stack_2byte(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
				{
					printf("Error happens in reading 2-byte-size RAW file. Stop. \n");
					return false;
				}
		}
	}else
	{
		return false;
	}
			
	     
	//copy output data
	
	switch (tmp_datatype)
	{
		case 1:
			datatype = 1;
			break;
			
		case 2:
			datatype = 2;
			break;
			
		case 4:
			datatype = 4;
			break;
			
		default:
			printf("Something wrong with the program, -- should NOT display this message at all. Check your program. \n");
			if (data1d) {delete []data1d; data1d=0;}
			if (tmp_sz) {delete []tmp_sz; tmp_sz=0;}
			if (sz) {delete []sz; sz=0;}
			if (szo) {delete []szo; szo=0;}
			return false;
	}
	
	
	szo = new V3DLONG [5];
	szo[0] = tmp_sz[0];
	szo[1] = tmp_sz[1]/resampling_size;
	szo[2] = tmp_sz[2]/resampling_size;
	szo[3] = tmp_sz[3]; //no longer merge the 3rd and 4th dimensions
	szo[4] = (b_5d) ? tmp_sz[4] : 1; 
	
	sz = new V3DLONG [5];
	sz[0] = tmp_sz[0];
	sz[1] = tmp_sz[1];
	sz[2] = tmp_sz[2];
	sz[3] = tmp_sz[3]; //no longer merge the 3rd and 4th dimensions
	sz[4] = (b_5d) ? tmp_sz[4] : 1; 
	
	//printf("x=%ld y=%ld z=%ld\n",sz[0],sz[1],sz[2]);
	
	//printf("xo=%ld yo=%ld zo=%ld\n",szo[0],szo[1],szo[2]);
	/* clean all workspace variables */
	data1d = tmp_data1d;
	if (tmp_sz) {delete []tmp_sz; tmp_sz=0;}
	
	return true;
}
bool loadImage_raw_resampling(char imgSrcFile[], unsigned char *& data1d, V3DLONG * &szo, V3DLONG *&sz, int & datatype,int &resampling_size) 
{
	if (data1d)
	{
		printf("Warning: The pointer for 1d data storage is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []data1d; data1d=0;
	}
	if (sz)
	{
		printf("Warning: The pointer for size is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []sz; sz=0;
	}
	else
	{
		sz = new V3DLONG [4];
		if (!sz)
		{
			printf("Fail to alocate memory for the size variable.\n");
			return false;
		}
	}
	
	if(szo)
	{
		printf("Warning: The pointer for size is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []szo; szo=0;
	}
	else
	{
		szo = new V3DLONG [4];
		if (!szo)
		{
			printf("Fail to alocate memory for the size variable.\n");
			return false;
		}
	}
	
	unsigned char *tmp_data1d =0;
	V3DLONG * tmp_sz = 0; /* note that this variable must be initialized as NULL. */
	V3DLONG * tmp_szo =0;
	int tmp_datatype = 0;
	int temp_res = 0;
	bool b_5d=false;
	char * curFileSuffix = getSurfix(imgSrcFile);
	if (b_VERBOSE_PRINT)
		printf("The current input file has the surfix [%s]\n", curFileSuffix);
		if ( strcasecmp(curFileSuffix, "raw")==0 ) //then assume it is Hanchuan's RAW format
		{
			if (b_VERBOSE_PRINT)
//				printf("The data is not with a TIF/LSM surfix, -- now this program assumes it is RAW format defined by Hanchuan Peng. \n");
//				if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //RAW file at most should be 1.5G bytes
//				{
//					printf("The RAW file may not exist or may be too big to load.\n");
//					return false;
//				}
			if (loadRaw2Stack_raw_resamping(imgSrcFile, tmp_data1d, tmp_szo, tmp_sz, tmp_datatype,temp_res))
			{
				if (b_VERBOSE_PRINT)
					printf("The data doesn't look like a correct 4-byte-size RAW file. Try 2-byte-raw. \n");
//					if (loadRaw2Stack_2byte(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
//					{
//						printf("Error happens in reading 2-byte-size RAW file. Stop. \n");
//						return false;
//					}
			}
		}else
		{
			return false;
		}
	
	
	//copy output data
	
	switch (tmp_datatype)
	{
		case 1:
			datatype = 1;
			break;
			
		case 2:
			datatype = 2;
			break;
			
		case 4:
			datatype = 4;
			break;
			
		default:
			printf("Something wrong with the program, -- should NOT display this message at all. Check your program. \n");
			if (data1d) {delete []data1d; data1d=0;}
			if (tmp_sz) {delete []tmp_sz; tmp_sz=0;}
			if (sz) {delete []sz; sz=0;}
			if (szo) {delete []szo; szo=0;}
			return false;
	}
	
	
	szo = new V3DLONG [5];
	szo[0] = tmp_szo[0];
	szo[1] = tmp_szo[1];
	szo[2] = tmp_szo[2];
	szo[3] = tmp_szo[3]; //no longer merge the 3rd and 4th dimensions
	szo[4] = (b_5d) ? tmp_szo[4] : 1; 
	
	sz = new V3DLONG [5];
	sz[0] = tmp_sz[0];
	sz[1] = tmp_sz[1];
	sz[2] = tmp_sz[2];
	sz[3] = tmp_sz[3]; //no longer merge the 3rd and 4th dimensions
	sz[4] = (b_5d) ? tmp_sz[4] : 1; 
	
	//printf("x=%ld y=%ld z=%ld\n",sz[0],sz[1],sz[2]);
	
	//printf("xo=%ld yo=%ld zo=%ld\n",szo[0],szo[1],szo[2]);
	/* clean all workspace variables */
	data1d = tmp_data1d;
	if (tmp_sz) {delete []tmp_sz; tmp_sz=0;}

	resampling_size = temp_res;
	
	return true;
}
bool saveImage(const char filename[], const unsigned char * data1d, const V3DLONG * sz, const int datatype)
{
	if (!data1d || !filename || !sz)
	{
		printf("This image data is empty or the file name or the size pointer is invalid. Nothing done.\n");
		return false;
	}

	int dt;
	switch (datatype)
	{
		case 1:  dt=1; break;
		case 2:  dt=2; break;
		case 4:  dt=4; break;
		default:
			printf("The data type is unsupported. Nothing done.\n");
			return false;
			break;
	}

	char * curFileSuffix = getSurfix((char *)filename);
    if (b_VERBOSE_PRINT)
		printf("The current input file has the surfix [%s]\n", curFileSuffix);
	if (strcasecmp(curFileSuffix, "tif")==0 || strcasecmp(curFileSuffix, "tiff")==0) //write tiff stacks
	{
		if (saveStack2Tif(filename, data1d, sz, dt))
		{
			printf("Error happens in writing TIF file [%s]. Stop. \n", filename);
			return false;
		}
	}
	else if (strcasecmp(curFileSuffix, "raw5")==0) //write .raw5 data
	{
		if (saveStack2Raw5d(filename, data1d, sz, dt))
		{
			printf("Error happens in writing V3D .raw5 file [%s]. Stop. \n", filename);
			return false;
		}
	}
	else //then assume it is Hanchuan's RAW format
	{
		if (b_VERBOSE_PRINT)
			printf("The data is not with a TIF surfix, -- now this program assumes it is RAW format defined by Hanchuan Peng. \n");
		if (saveStack2Raw(filename, data1d, sz, dt)!=0) //0 is no error //note that as I updated the saveStack2Raw to RAW-4-byte, the actual mask file cannot be read by the old wano program, i.e. the wano must be updated on Windows machine as well. 060921
		{
			printf("Error happens in writing RAW file stack [defined by Hanchuan Peng] [%s].\n", filename);
			return false;
		}
	}

	return true;
}


#endif //__STACKUTIL_CPP__

